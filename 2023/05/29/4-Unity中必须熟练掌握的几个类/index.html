<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity中必须熟练掌握的几个类 | maolele'blog</title><meta name="author" content="maolele"><meta name="copyright" content="maolele"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Unity中必须熟练掌握的几个类 Unity中必须熟练掌握的几个类：  GameObject Component Transform MonoBehaviour  另外，还需要熟悉：  Object：UnityEngine中所有的类都派生于UnityEngine.Object Time  常用类的继承关系：  所有类的最远父类都是Object； GameObject">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity中必须熟练掌握的几个类">
<meta property="og:url" content="http://example.com/2023/05/29/4-Unity%E4%B8%AD%E5%BF%85%E9%A1%BB%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E7%B1%BB/index.html">
<meta property="og:site_name" content="maolele&#39;blog">
<meta property="og:description" content="Unity中必须熟练掌握的几个类 Unity中必须熟练掌握的几个类：  GameObject Component Transform MonoBehaviour  另外，还需要熟悉：  Object：UnityEngine中所有的类都派生于UnityEngine.Object Time  常用类的继承关系：  所有类的最远父类都是Object； GameObject">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/maolele.jpg">
<meta property="article:published_time" content="2023-05-29T04:02:06.000Z">
<meta property="article:modified_time" content="2023-05-29T04:03:06.994Z">
<meta property="article:author" content="maolele">
<meta property="article:tag" content="游戏开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/maolele.jpg"><link rel="shortcut icon" href="/img/maolele.jpg"><link rel="canonical" href="http://example.com/2023/05/29/4-Unity%E4%B8%AD%E5%BF%85%E9%A1%BB%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E7%B1%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity中必须熟练掌握的几个类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-29 12:03:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/maolele.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="maolele'blog"><span class="site-name">maolele'blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity中必须熟练掌握的几个类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-29T04:02:06.000Z" title="发表于 2023-05-29 12:02:06">2023-05-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-29T04:03:06.994Z" title="更新于 2023-05-29 12:03:06">2023-05-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity中必须熟练掌握的几个类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="unity中必须熟练掌握的几个类">Unity中必须熟练掌握的几个类</h1>
<p>Unity中必须熟练掌握的几个类：</p>
<ul>
<li><p>GameObject</p></li>
<li><p>Component</p></li>
<li><p>Transform</p></li>
<li><p>MonoBehaviour</p></li>
</ul>
<p>另外，还需要熟悉：</p>
<ul>
<li>Object：UnityEngine中所有的类都派生于UnityEngine.Object</li>
<li>Time</li>
</ul>
<p>常用类的继承关系：</p>
<ul>
<li><p>所有类的最远父类都是Object；</p></li>
<li><p>GameObject、Component、Texture、Mesh、Material都直接由Object派生而来；</p></li>
<li><p>Transform、Rigidbody、ParticleSystem、Behaviour、Collider、Renderer都派生于Component，它们都是组件；</p></li>
<li><p>MonoBehaviour、Camera、Animator、AudioSource、Light、Animation、AudioListener都派生于Behaviour；</p></li>
<li><p>我们游戏开发人员自己编写的脚本，若想挂载到游戏对象上，须继承MonoBehaviour。</p></li>
</ul>
<p>​ 我们的脚本继承了<code>MonoBehaviour</code>后，可以直接在脚本中使用父类中所有的<code>public</code>、<code>protected</code>成员，另外，因为<code>MonoBehaviour</code>的上层父类继承了<code>Component</code>，所以我们我们的脚本对象也是一种组件。</p>
<h2 id="object">Object</h2>
<p>UnityEngine.Object的所有成员参看：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/2023.2/Documentation/ScriptReference/Object.html">Unity - Scripting API: Object (unity3d.com)</a></p>
<h3 id="概览">概览</h3>
<ul>
<li>属性
<ul>
<li>hideFlags</li>
<li><strong>name</strong></li>
</ul></li>
<li>公有方法
<ul>
<li>GetInstanceID</li>
<li>ToString</li>
</ul></li>
<li>静态方法
<ul>
<li><strong>Destroy</strong></li>
<li><strong>DestroyImmediate</strong></li>
<li><strong>DontDestroyOnLoad</strong></li>
<li>FindAnyObjectByType</li>
<li>FindFirstObjectByType</li>
<li>FindObjectsByTeype</li>
<li>FindObjectsOfType</li>
<li><strong>Instantiate</strong></li>
</ul></li>
</ul>
<h3 id="实例化对象">实例化对象</h3>
<p>根据一个GameObject对象的引用复制出一个新的对象：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject obj = Instantiate(myObj);</span><br></pre></td></tr></table></figure>
<h3 id="删除对象">删除对象</h3>
<h4 id="destroy">Destroy</h4>
<p><code>Destroy()</code>方法调用后并不会立即删除对象，一般情况会在下一帧中从内存中删除。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GameObject.Destroy(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数：延迟几秒删除</span></span><br><span class="line">GameObject.Destroy(obj5, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h4 id="destroyimmdiate">DestroyImmdiate</h4>
<p>使用<code>DestroyImmdiate()</code>方法可以立即删除对象。一般情况下不使用这个方法，如果在同一帧中大量调用该方法销毁对象，可能会导致游戏卡顿。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject.DestroyImmediate(obj);</span><br></pre></td></tr></table></figure>
<h4 id="dontdestroyonload">DontDestroyOnLoad</h4>
<p>默认情况下，在切换场景时，之前场景中的对象会自动被删除。如果不希望某个对象在切换场景时被删除，可以使用<code>DontDestroyOnLoad()</code>方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在下面的方法中传入想在过场景时保留的对象</span></span><br><span class="line">DontDestroyOnLoad(<span class="keyword">this</span>.gameObject);  <span class="comment">// 设置自己依附的GameObject过场景不被删除</span></span><br></pre></td></tr></table></figure>
<h2 id="monobehaviour">MonoBehaviour</h2>
<p>MonoBehaviour的所有成员参看：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/2023.2/Documentation/ScriptReference/MonoBehaviour.html">Unity - Scripting API: MonoBehaviour (unity3d.com)</a></p>
<h3 id="概览-1">概览</h3>
<ul>
<li>属性
<ul>
<li>runInEditMode</li>
<li>useGUILayout</li>
</ul></li>
<li>公有方法
<ul>
<li>CancelInvoke</li>
<li>Invoke</li>
<li>InvokeRepeating</li>
<li>IsInvoking</li>
<li>StartCoroutine</li>
<li>StopAllCoroutines</li>
<li>StopCoroutine</li>
</ul></li>
<li>静态方法
<ul>
<li>print：向控制台打印输出，该方法调用了<code>Debug.Log()</code>，功能完全一样，仅仅是为了再次封装，调用起来更方便；</li>
</ul></li>
<li>消息(Messages)
<ul>
<li>Awake</li>
<li>Start</li>
<li>FixedUpdate</li>
<li>Update</li>
<li>LateUpdate</li>
<li>...</li>
<li>这些消息都是Unity的生命周期函数</li>
</ul></li>
<li>MonoBehaviour派生于Behaviour，而Behaviour又派生于Component，所以Behaviour和Component中存在的属性、方法，在MonoBehaviour中也存在；</li>
<li>在Behaviour类中定义了两个属性：
<ul>
<li>enable</li>
<li>isActiveAndEnabled</li>
</ul></li>
</ul>
<p>下面列出一些继承了MonoBehaviour的类中可以执行的操作，不单独讲是Behaviour的还是Component类的。</p>
<h3 id="数据成员">数据成员</h3>
<p>当前脚本继承了<code>MonoBehaviour</code>类，而<code>MonoBehaviour</code>的父类<code>Component</code>中有一个<code>gameObject</code>属性：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject gameObject&#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>它是当前脚本(组件)所依附的GameObject对象。</p>
<p>所以我们可以在当前脚本中直接使用<code>gameObject</code>来获取脚本所依附的GameObject对象。</p>
<p>另外，<code>GameObject</code>类中还有其他组件类型的属性：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Componet transform &#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>这些父类中的这些属性存储了对应组件对象的引用，所以我们可以直接在脚本中使用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="keyword">this</span>.transform.position);</span><br><span class="line"><span class="comment">// GameObject类中也也有transform属性</span></span><br><span class="line">print(<span class="keyword">this</span>.gameObject.transform.position);  <span class="comment">// 与上面本质是一样的</span></span><br></pre></td></tr></table></figure>
<p>设置当前脚本的激活/失活：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.enabled = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>获取其他脚本所依附的GameObject的信息：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Script2</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处的Script1也是一个继承了MonoBehaviour的脚本</span></span><br><span class="line">    <span class="comment">// 在编辑器中使用拖拽赋值</span></span><br><span class="line">	<span class="keyword">public</span> Script1 otherScript;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">    	print(otherScript.gameObject.name);</span><br><span class="line">    	print(otherScript.transform.position);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员方法">成员方法</h3>
<p>下面是一些用于获取当前脚本对象所依附的GameObject对象所挂载的组件的方法。</p>
<p>这些方法在<code>GameObject</code>类中也有。</p>
<h4 id="获取gameobject上挂载的组件">获取GameObject上挂载的组件</h4>
<h5 id="获取gameobject上挂载的单个组件">获取GameObject上挂载的单个组件</h5>
<p>通过组件名获取：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">this</span>.GetComponent(<span class="string">&quot;Test&quot;</span>) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure>
<p>通过组件类型获取：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">this</span>.GetComponent(<span class="keyword">typeof</span>(Test)) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure>
<p>通过泛型获取，这是最常用的一种方式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">this</span>.GetComponent&lt;Test&gt;();</span><br></pre></td></tr></table></figure>
<p>上面这些方法如果获取失败，则返回<code>null</code>。</p>
<p>如果GameObject上挂载了多个同类型的组件，我们通过上面的方法获取该类型的组件，无法确定最终获取到的具体是哪一个组件。</p>
<h5 id="获取gameobject上挂载的多个组件">获取GameObject上挂载的多个组件</h5>
<p>根据泛型获取，组件对象的引用存储至数组，并返回：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test[] arrary = <span class="keyword">this</span>.GetComponents&lt;Test&gt;();</span><br></pre></td></tr></table></figure>
<p>根据泛型获取，将list作为参数传入，组件对象的引用存储至list中。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Test&gt; list = <span class="keyword">new</span> List&lt;Test&gt;();</span><br><span class="line"><span class="keyword">this</span>.GetComponents&lt;Test&gt;(list);</span><br></pre></td></tr></table></figure>
<h4 id="获取自己以及子孙物体上挂载的组件">获取自己以及子孙物体上挂载的组件</h4>
<h5 id="获取单个组件">获取单个组件</h5>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到子物体上挂载的组件(默认也会找自身上是否挂载该组件)</span></span><br><span class="line"><span class="comment">// 参数true：失活的物体也进行查找(默认为false，只查找激活的物体)</span></span><br><span class="line">Test t = <span class="keyword">this</span>.GetComponentInChilder&lt;Test&gt;(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h5 id="获取多个组件">获取多个组件</h5>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到子物体挂载的多个组件(默认也会找自身上是否挂载该组件)</span></span><br><span class="line">Test[] arr = <span class="keyword">this</span>.GetComponentsInChildren&lt;Test&gt;(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Test&gt; list = <span class="keyword">new</span> List&lt;Test&gt;();</span><br><span class="line"><span class="keyword">this</span>.GetComponentsInChildren&lt;Test&gt;(<span class="literal">true</span>, list);</span><br></pre></td></tr></table></figure>
<h4 id="获取自己以及父物体包括祖先上挂载的组件">获取自己以及父物体(包括祖先)上挂载的组件</h4>
<h5 id="获取单个组件-1">获取单个组件</h5>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test t = <span class="keyword">this</span>.GetComponentInParent&lt;Test&gt;();</span><br></pre></td></tr></table></figure>
<h5 id="获取多个组件-1">获取多个组件</h5>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Test[] arr = <span class="keyword">this</span>.GetComponentsInParent&lt;Test&gt;();</span><br><span class="line"></span><br><span class="line">List&lt;Test&gt; list = <span class="keyword">new</span> List&lt;Test&gt;();</span><br><span class="line"><span class="keyword">this</span>.GetComponentsInParent&lt;Test&gt;(list);</span><br></pre></td></tr></table></figure>
<h4 id="尝试获取脚本">尝试获取脚本</h4>
<p>使用<code>TryGetComponent&lt;ComponentType&gt;()</code>函数获取组件对象，参数是<code>out</code>类型的参数，返回值是<code>bool</code>类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test test;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.TryGetComponent&lt;Test&gt;(<span class="keyword">out</span> test))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 逻辑处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gameobject">GameObject</h2>
<p>GameObject的所有成员参看：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/2023.2/Documentation/ScriptReference/GameObject.html">Unity - Scripting API: GameObject (unity3d.com)</a></p>
<h3 id="概览-2">概览</h3>
<ul>
<li>属性
<ul>
<li>activeInHierarchy</li>
<li>activeSelf</li>
<li>isStatic</li>
<li>layer</li>
<li>scene</li>
<li>sceneCullingMask</li>
<li><strong>tag</strong>：Component类中也有</li>
<li><strong>transform</strong>：Component类中也有</li>
<li>可以看到，除了Component类中的属性，除了没有<code>gameObject</code>属性以外，其他的属性在GameObject中也同样有。</li>
</ul></li>
<li>公有方法
<ul>
<li>AddComponent</li>
<li>BroadcastMessage：Component类中也有</li>
<li>CompareTag：Component类中也有</li>
<li>GetComponent：Component类中也有</li>
<li>GetComponentInChildern：Component类中也有</li>
<li>GetComponentInParent：Component类中也有</li>
<li>GetComponents：Component类中也有</li>
<li>GetComponentsInChildren：Component类中也有</li>
<li>GetComponetsInParent：Component类中也有</li>
<li>SendMessage：Component类中也有</li>
<li>SendMessageUpwards：Component类中也有</li>
<li>SetActive</li>
<li>TryGetComponent：Component类中也有</li>
<li>可以看到，Component类中所有的公有方法，在GameObject类中也有，但GameObject并不派生于Component；</li>
<li>为什么要在Component类中也定义这些获取组件的方法？
<ul>
<li>从逻辑上讲，获取组件获取的是某一个游戏物体的组件，应该把获取组件相关的方法定义在游戏物体的类中，而组件的类中不需要定义；</li>
<li>我们自己编写的脚本，在挂载后创建的脚本对象，它也是一种组件。我们编写的游戏逻辑是写在脚本中的，在脚本中常常需要获取脚本所依附的游戏物体上的其他组件，所以需要在Component类中定义获取组件相关的方法。</li>
</ul></li>
</ul></li>
<li>静态方法
<ul>
<li>CreatePrimitive</li>
<li>Find</li>
<li>FindGameObjectsWithTag</li>
<li>FindWithTag</li>
</ul></li>
<li>GameObject类继承了Object类，所以还拥有了Object中有所的公有、静态方法。</li>
</ul>
<h3 id="数据成员-1">数据成员</h3>
<h4 id="获取依附的gameobject">获取依附的GameObject</h4>
<p>父类<code>MonoBehaviour</code>中定义了只读属性<code>gameObject</code>，其值为当前脚本对象依附的GameObject的引用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.gameObject;</span><br><span class="line"><span class="keyword">this</span>.gameObject.name;  <span class="comment">// string类型</span></span><br><span class="line"><span class="keyword">this</span>.gameObject.name = <span class="string">&quot;LiHua&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="获取gameobject的transform组件相关信息">获取GameObject的Transform组件相关信息</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.transform.position;  <span class="comment">// 位置</span></span><br><span class="line"><span class="keyword">this</span>.transform.eulerAngles;  <span class="comment">// 角度</span></span><br><span class="line"><span class="keyword">this</span>.transform.lossyScale;  <span class="comment">// 缩放大小</span></span><br><span class="line"><span class="keyword">this</span>.gameObject.transform;</span><br></pre></td></tr></table></figure>
<h4 id="获取脚本依附的gameobject是否激活">获取脚本依附的GameObject是否激活</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 游戏对象是否激活</span></span><br><span class="line"><span class="keyword">this</span>.gameObject.activateSelf;</span><br><span class="line"><span class="comment">// 游戏对象是否静态(static)</span></span><br><span class="line"><span class="keyword">this</span>.gameObject.isStatic;</span><br></pre></td></tr></table></figure>
<h4 id="获取gameobject的层级和标签">获取GameObject的层级和标签</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层级</span></span><br><span class="line"><span class="keyword">this</span>.gameObject.layer;  <span class="comment">// 返回的是int类型的值</span></span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line"><span class="keyword">this</span>.gameObject.tag;   <span class="comment">// 返回的是一个字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="获取其他组件依附的gameobject的信息">获取其他组件依附的GameObject的信息</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> Test otherTest;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">    	print(otherTest.gameObject.name);</span><br><span class="line">    	print(otherTest.transform.position);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态方法">静态方法</h3>
<h4 id="创建几何体">创建几何体</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 准备用来克隆的对象</span></span><br><span class="line">	<span class="comment">// 1. 可以是场景上的某个对象</span></span><br><span class="line">    <span class="comment">// 2. 可以是一个预制体对象</span></span><br><span class="line">	<span class="keyword">public</span> GameObject myObj;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="comment">// 创建几何体</span></span><br><span class="line">    	<span class="comment">// 参数是枚举类型:</span></span><br><span class="line">        <span class="comment">// Capsule, Cube, Cylinder, Plane, Quad, Sphere</span></span><br><span class="line">    	myObj = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找gameobject">查找GameObject</h4>
<h5 id="查找单个gameobject">查找单个GameObject</h5>
<p>通过对象名查找：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过对象名查找(这种查找效率较低，会在场景中的所有对象去查找),未找到则返回null</span></span><br><span class="line">GameObject obj = GameObject.Find(<span class="string">&quot;啊哈&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>通过tag查找：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过tag查找对象</span></span><br><span class="line">GameObject obj1 = GameObject.FindWithTag(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个方法与上面的方法只是方法名字的区别</span></span><br><span class="line">GameObject obj2 = GameObject.FindGameObjectWithTag(<span class="string">&quot;Player&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>前面两种查找游戏物体对象的方法的共同点：</p>
<ol type="1">
<li>只能查找激活的对象；</li>
<li>当前场景中如果有多个满足条件的对象，则无法确定最终找到的具体是哪个对象。</li>
</ol>
<p>另外，我们可以使用UnityEngine.Object类提供的静态方法<code>FindObjectOfType&lt;ComponentType&gt;()</code>等，先获取组件对象，再根据组件对象获取其依附的GameObject对象。但是这样的效率非常低，它不仅要要遍历场景中的对象，还需要遍历对象上的组件。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test test = GameObject.FindObjectOfType&lt;Test&gt;();</span><br><span class="line">print(test.gameObject.name);</span><br></pre></td></tr></table></figure>
<h5 id="查找多个gameobject">查找多个GameObject</h5>
<p>找多个对象的API只能是通过tag查找多个,通过名字不能查找多个：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过tag找多个对象(只能找到激活的对象，无法找到失活的对象)</span></span><br><span class="line">GameObject[] objs = GameObject.FindGameObjectsWithTag(<span class="string">&quot;Player&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="成员方法-1">成员方法</h3>
<h4 id="创建新的gameobject">创建新的GameObject</h4>
<p>直接<code>new GameObject()</code>即可，创建之后，该游戏物体就会存在于游戏场景中。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GameObject obj = <span class="keyword">new</span> GameObject();</span><br><span class="line"></span><br><span class="line">GameObject obj = <span class="keyword">new</span> GameObject(<span class="string">&quot;name&quot;</span>);  <span class="comment">// 可以通过传递第一个参数来设置物体的name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在创建物体的同时给物体添加组件</span></span><br><span class="line">GameObjcet obj8 = </span><br><span class="line">    <span class="keyword">new</span> GameObjcet(<span class="string">&quot;创建空物体并挂载一个脚本&quot;</span>, </span><br><span class="line">                                 <span class="keyword">typeof</span>(Component1),</span><br><span class="line">                                 <span class="keyword">typeof</span>(Component2)</span><br><span class="line">                                );</span><br></pre></td></tr></table></figure>
<h4 id="为gameobject对象添加组件">为GameObject对象添加组件</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为对象添加组件</span></span><br><span class="line">Test test1 = obj.addComponent(<span class="keyword">typeof</span>(Test)) <span class="keyword">as</span> Test;</span><br><span class="line"><span class="comment">// 用泛型更方便</span></span><br><span class="line">Test test2 = obj.AddComponent&lt;Test&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="获取gameobject上挂载的组件-1">获取GameObject上挂载的组件</h4>
<p>同Component类中的那些获取组件的方法。</p>
<h4 id="标签比较">标签比较</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> flag = <span class="keyword">this</span>.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"><span class="comment">// 或:</span></span><br><span class="line"><span class="built_in">bool</span> flag = <span class="keyword">this</span>.gameObject.tag == <span class="string">&quot;Player&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="设置激活失活">设置激活/失活</h4>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.SetActive(<span class="literal">false</span>);  <span class="comment">// 设置失活</span></span><br></pre></td></tr></table></figure>
<h4 id="广播消息">广播/消息</h4>
<p>通知GameObject执行名为某个函数名的方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.SendMessage(<span class="string">&quot;TestFun1&quot;</span>);</span><br><span class="line"><span class="comment">// 第二个及后面的所有参数作为要调用的方法的实参</span></span><br><span class="line">obj.SendMessage(<span class="string">&quot;TestFun2&quot;</span>, <span class="number">666</span>);</span><br></pre></td></tr></table></figure>
<p>该功能会在GameObject自己身上挂载的所有组件中去找这个名字的方法，所以该方法的执行效率比较低。通常不使用该方法，一般都是先获取对应的组件，然后在通过该组件来调用组件对应的方法，下面的两个方法也是同理。</p>
<p>通知当前GameObject自己以及该GameObject的子物体执行某个方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.BroadcastMessage(<span class="string">&quot;FuncName&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>通知当前GameObject自己以及该GameObject的父物体执行某个方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.SendMessageUpwards(<span class="string">&quot;FuncName&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="time">Time</h2>
<p>UnityEngine命名空间中的<code>Time</code>包含了更时间相关的API。<code>Time</code>类中的所有成员都是静态的属性，因此，可以直接通过类名进行调用。</p>
<h3 id="时间放缩比例">时间放缩比例</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time.timeScale = <span class="number">0</span>;  <span class="comment">// 时间停止</span></span><br><span class="line">Time.timeScale = <span class="number">2</span>;  <span class="comment">// 时间变为2倍</span></span><br><span class="line">Time.timeScale = <span class="number">1</span>;  <span class="comment">// 正常的时间比例</span></span><br></pre></td></tr></table></figure>
<h3 id="帧间隔时间">帧间隔时间</h3>
<p>帧间隔时间指的是执行当前这行代码的时间与上一帧中执行这行代码的时间的间隔。帧间隔时间的单位为秒。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time.deltaTime;  <span class="comment">// 受Time.timeScale影响</span></span><br><span class="line"><span class="comment">// Time.deltaTime = Time.unscaleDeltaTime * Time.timeScale;</span></span><br><span class="line">Time.unscaleDeltaTime;  <span class="comment">// 不受Time.timeScale影响</span></span><br></pre></td></tr></table></figure>
<p>帧间隔时间主要用来计算位移。平均路程=时间*平均速度。</p>
<p>假设，现在需要让某个物体在每帧中移动一次：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> </span><br><span class="line">&#123;</span><br><span class="line">    transform.Translate(<span class="number">0</span>, <span class="number">0</span>, distancePerFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 由于<code>Update</code>的调用受帧率的影响，在需要大量渲染时，<code>Update</code>的调用间隔较大，在渲染量较小时，<code>Update</code>调用的间隔较小，另外<code>Update</code>的调用还受硬件配置的影响。所以上述代码并不能保证物体是匀速移动的。</p>
<p>​ 所以需要使用<code>Time.deltaTime</code>来缩放当前帧需移动到的距离：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.Translate(<span class="number">0</span>, <span class="number">0</span>, distancePerFrame * Time.deltaTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="游戏开始到现在的时间">游戏开始到现在的时间</h3>
<p>游戏运行到现在的时间常用于单机游戏，在网络游戏中，时间是以服务器的时间为准的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time.time;  <span class="comment">// 游戏开始运行到现在的时间(受Time.scale影响)</span></span><br><span class="line">Time.unscaledTime;  <span class="comment">// 不受Time.scale影响</span></span><br></pre></td></tr></table></figure>
<h3 id="物理帧间隔时间">物理帧间隔时间</h3>
<p>物理帧间隔时间默认为0.02s，物理帧间隔时间在游戏运行的整个过程中都是固定的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time.fixedDeltaTime;  <span class="comment">// 物理帧间隔时间(受Time.scale影响)</span></span><br><span class="line">Time.fixedUnscaleDeltaTime;  <span class="comment">// 不受Time.scale影响</span></span><br></pre></td></tr></table></figure>
<h3 id="游戏开始到现在的帧数">游戏开始到现在的帧数</h3>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time.frameCount;</span><br></pre></td></tr></table></figure>
<h2 id="transform">Transform</h2>
<p>Transform的所有成员参看：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/2023.2/Documentation/ScriptReference/Transform.html">Unity - Scripting API: Transform (unity3d.com)</a></p>
<h3 id="概览-3">概览</h3>
<ul>
<li>属性
<ul>
<li>childCount</li>
<li>eulerAngles：欧拉角</li>
<li>localEulerAngles</li>
<li>forword</li>
<li>localPosition</li>
<li>localRotation</li>
<li>localScale</li>
<li>parent</li>
<li>position</li>
<li>right</li>
<li>root</li>
<li>rotation</li>
<li>up</li>
<li>...</li>
</ul></li>
<li>公有方法
<ul>
<li>LookAt</li>
<li>Roate</li>
<li>RotateAround</li>
<li>Translate</li>
</ul></li>
</ul>
<p>​ 游戏对象(GameObject)的位移、旋转、缩放、父子关系、坐标转换等相关操作都由Transform对象管理的。</p>
<h3 id="vector">Vector</h3>
<p>在学习<code>Transform</code>相关成员之前，需要先了解Vector。</p>
<p><code>Vector3</code>三维向量，<code>Vector2</code>是二维向量。</p>
<p><code>Vector3</code>的三个属性<code>x</code>, <code>y</code>, <code>z</code>是三维向量的三个坐标。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector2 v1 = <span class="keyword">new</span> Vector2(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Vector3 v2 = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>Vector实现了<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>的运算符重载。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector3 v1 = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>， <span class="number">1</span>);</span><br><span class="line">Vector3 v12 = <span class="keyword">new</span> Vector3(<span class="number">2</span>, <span class="number">2</span>， <span class="number">2</span>);</span><br><span class="line">print(v1 + v12);  <span class="comment">// (3.0, 3.0, 3.0)</span></span><br><span class="line">print(v1 - v12);  <span class="comment">// (-1.0, -1.0, -1.0)</span></span><br><span class="line">print(v1 * <span class="number">10</span>);  <span class="comment">// (10.0, 10.0, 10.0)</span></span><br><span class="line">print(v12 / <span class="number">2</span>);  <span class="comment">// (1.0, 1.0, 1.0)</span></span><br></pre></td></tr></table></figure>
<p>常用的向量：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(Vector3.zero);  <span class="comment">// (0.0, 0.0, 0.0)</span></span><br><span class="line">print(Vector3.right);  <span class="comment">// (1.0, 0.0, 0.0)</span></span><br><span class="line">print(Vector3.left);  <span class="comment">// (-1.0, 0.0, 0.0)</span></span><br><span class="line">print(Vector3.forward);  <span class="comment">// (0.0, 0.0, 1.0)</span></span><br><span class="line">print(Vector3.back);  <span class="comment">// (0.0, 0.0, -1.0)</span></span><br><span class="line">print(Vector3.up);  <span class="comment">// (0.0, 1.0, 0.0)</span></span><br><span class="line">print(Vector3.down);  <span class="comment">// (0.0, -1.0, 0.0)</span></span><br><span class="line">print(Vector3.one);  <span class="comment">// (1.0, 1.0, 1.0)</span></span><br></pre></td></tr></table></figure>
<p>计算两个向量之间的距离：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3.Distance(v1, v12);</span><br></pre></td></tr></table></figure>
<h3 id="transform的常用属性">Transform的常用属性</h3>
<p>位置信息：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform.position;  <span class="comment">// 相对于世界坐标系</span></span><br><span class="line">transform.localPosition;  <span class="comment">// 相对于父物体(如果没有父物体,则与transform.position相同)</span></span><br></pre></td></tr></table></figure>
<p><code>transform.position</code>和<code>transform.localPosition</code>的<code>x</code>, <code>y</code>, <code>z</code>都是只读属性，不可赋值。如果想要修改<code>position</code>，可以对其重新赋一个向量：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform.position = <span class="keyword">new</span> Vector3(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">transform.localPosition = Vector3.up * <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>游戏物体当前的朝向：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物体当前的面朝向</span></span><br><span class="line">transform.forward;</span><br><span class="line"><span class="comment">// 物体当前的头顶朝向</span></span><br><span class="line">transform.up;</span><br><span class="line"><span class="comment">// 物体当前的右手边</span></span><br><span class="line">transform.right;</span><br><span class="line"><span class="comment">// 其他同理</span></span><br></pre></td></tr></table></figure>
<h3 id="使gameobject进行位移">使GameObject进行位移</h3>
<p>计算位移：</p>
<p>位移 = 速度 * 时间；</p>
<p>而速度又包含的速率和方向，只有知道了这三者才能正确的将游戏物体进行位移。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> speed = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 往游戏物体自己的面朝向移动</span></span><br><span class="line">transform.position += transform.forward * speed * Time.deltaTime;</span><br><span class="line"><span class="comment">// 往世界坐标系的Z轴方向移动</span></span><br><span class="line">transform.position += Vector3.forward * speed * Time.deltaTime;</span><br></pre></td></tr></table></figure>
<p>我们还可以调用<code>transform.Translate()</code>方法来实现同样的效果。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：位移</span></span><br><span class="line"><span class="comment">// 参数2：相对的坐标系;该参数默认是相对于物体自己的坐标系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于世界坐标系朝z轴移动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(Vector3.forward * <span class="number">1</span> * Time.deltaTime, Space.World);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于世界坐标系让物体朝自己的面朝向移动</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(<span class="keyword">this</span>.transform.forward * <span class="number">1</span> * Time.deltaTime, Space.World);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于自己的坐标系下的z轴正方向移动(始终朝自己的面朝向移动)</span></span><br><span class="line"><span class="keyword">this</span>.transform.Translate(Vector3.forward * <span class="number">1</span> * Time.deltaTime, Space.Self);</span><br></pre></td></tr></table></figure>
<h3 id="角度和旋转">角度和旋转</h3>
<p>欧拉角：</p>
<p><code>transform.localEulerAngles</code>获取的欧拉角就是Inspector窗口中Transform的Rotation显示的数据(相对于父对象的欧拉角)。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform.eulerAngles;  <span class="comment">// 相对于世界坐标系</span></span><br><span class="line">transform.localEulerAngles; <span class="comment">// 相对于父物体</span></span><br></pre></td></tr></table></figure>
<p>与<code>transform.position</code>一样，不能单独修改其<code>x</code>, <code>y</code>, <code>z</code>，若要修改需要重新赋一个Vector3对象，后面的缩放比例也是一样。</p>
<p>自转：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个轴具体转多少度</span></span><br><span class="line"><span class="comment">// 参数1：每帧x, y, z轴方向旋转的角度</span></span><br><span class="line"><span class="comment">// 参数2：默认相对于自己坐标系进行的旋转</span></span><br><span class="line">transform.Rotate(<span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>) * Time.deltaTime, Space.Self);</span><br></pre></td></tr></table></figure>
<p>绕轴旋转：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1：相对于哪轴进行转动</span></span><br><span class="line"><span class="comment">// 参数2：转动的角度</span></span><br><span class="line"><span class="comment">// 参数3：默认相对于自己的坐标系进行旋转</span></span><br><span class="line">transform.Rotate(Vector3.up, <span class="number">10</span> * Time.deltaTime, Space.World);</span><br></pre></td></tr></table></figure>
<p>绕某点旋转(类似于地球绕太阳公转)：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对于某一个点转</span></span><br><span class="line"><span class="comment">// 参数1：相对于哪一个点</span></span><br><span class="line"><span class="comment">// 参数2：相对于哪一个点的哪一个轴</span></span><br><span class="line"><span class="comment">// 参数3：转的度数 旋转速度 * 时间</span></span><br><span class="line"><span class="keyword">this</span>.transform.RotateAround(Vector3.zero, Vector3.up, <span class="number">10</span> * Time.deltaTime);</span><br></pre></td></tr></table></figure>
<h3 id="缩放和看向">缩放和看向</h3>
<p>缩放比例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相对于世界坐标系</span></span><br><span class="line">transform.lossyScale;</span><br><span class="line"><span class="comment">// 相对于本地坐标系(父物体)</span></span><br><span class="line">transform.localScale;</span><br><span class="line"></span><br><span class="line">transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>看向：</p>
<p>让GameObject对象的面朝向(物体的Z轴方向)看向某一个点或某一个对象(都是相对于世界坐标系)。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看向一个点</span></span><br><span class="line"><span class="comment">// 该方法还有第二个参数, 是在旋转时相对于哪个轴进行旋转, 默认为y轴</span></span><br><span class="line">transform.LookAt(Vector3.zero);</span><br><span class="line"><span class="comment">// 看向一个对象(传入一个对象的Transform信息)</span></span><br><span class="line">transform.LookAt(otherTransform);</span><br></pre></td></tr></table></figure>
<h3 id="父子关系">父子关系</h3>
<p>获取父物体GameObject：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.parent;</span><br></pre></td></tr></table></figure>
<p>父物体是可以修改的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置当前GameObject无父物体</span></span><br><span class="line">transform.parent = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 或:</span></span><br><span class="line">transform.SetParent(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让otherTransform依附的GameObject作为当前GameObject的父物体</span></span><br><span class="line">transform.parent = otherTransform;</span><br><span class="line"><span class="comment">// 或:</span></span><br><span class="line">transform.SetParent(otherTransform);</span><br></pre></td></tr></table></figure>
<p><code>transform.SetParent(Transform parent, bool worldPositionStays)</code>的参数：</p>
<p>参数1：父物体的transform；</p>
<p>参数2：是否保留世界坐标的位置、角度、缩放比例，默认为 <code>true</code>；</p>
<p>为<code>true</code>：当子物体的位置、角度、缩放比例会根据父物体对应的值进行计算。例如：</p>
<p>父物体的position: 10, 10, 10, localScale: 2, 2, 2，子物体的position: 0, 0, 0, localScale: 1, 1, 1。取消该父物体后，子物体的position: 10, 10, 10, localScale: 2, 2, 2。使得该子物体在解除父子关系后相对于世界坐标系的大小、位置、角度都不变。</p>
<p>为<code>false</code>：当某物体成为另外一个物体的子物体时，直接把原先相对于世界坐标系的坐标设为相对于父物体的坐标，没有根据父物体的信息进行计算，所以在成为子物体后，其相对于世界坐标系的位置、大小、旋转可能会发生改变。</p>
<p>解除所有的子物体(不影响子孙之间的父子关系)：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.DetachChildren();</span><br></pre></td></tr></table></figure>
<p>获取子物体：</p>
<p><code>transform.Find()</code>查找不包括孙物体，只能找自己下一级的子物体；查找效率比<code>GameObject.Find()</code>高。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按子物体的name进行查找(可查找失活的子物体)</span></span><br><span class="line">transform.Find(<span class="string">&quot;Cube (1)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按子物体索引号获取子物体</span></span><br><span class="line"><span class="comment">// 如果索引超出子物体索引的范围, 则会报错</span></span><br><span class="line">Transform t = transform.GetChild(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>获取子物体的个数：</p>
<p><code>transform.childCount</code>不包括孙物体的个数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.childCount;  <span class="comment">// 包括激活和失活的子物体</span></span><br></pre></td></tr></table></figure>
<p>判断自身是否是某个物体的子物体：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trans.IsChildOf(OtherTransform);</span><br></pre></td></tr></table></figure>
<p>获取自身作为子物体的索引：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trans.GetSiblingIndex();</span><br></pre></td></tr></table></figure>
<p>将自己设置为父物体的第一个子物体：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trans.SetAsFirstSibling();</span><br></pre></td></tr></table></figure>
<p>将自己设为父物体的最后一个子物体：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trans.SetAsLastSibling();</span><br></pre></td></tr></table></figure>
<p>将自己设置为指定索引的子物体：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当索引超出范围时会设置为索引范围内的最后一个索引</span></span><br><span class="line">trans.SetSiblingIndex(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<h3 id="世界坐标与本地坐标的转换">世界坐标与本地坐标的转换</h3>
<p>世界坐标系的坐标转换为本地坐标坐标：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform.InverseTransformPoint(Vector3.forward);</span><br></pre></td></tr></table></figure>
<p>世界坐标系的方向转换本地坐标系的方向：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform.InverseTransfromDirection(Vector3.forward);  <span class="comment">// 不受scale影响</span></span><br><span class="line">transform.InverseTransformVector(Vector3.forward);  <span class="comment">// 受scale影响</span></span><br></pre></td></tr></table></figure>
<p>本地坐标系坐标转换为世界坐标系坐标：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform.TransformPoint(Vector3.forward);  <span class="comment">// 不受scale影响</span></span><br><span class="line">transform.TransformVector(Vector3.forward);  <span class="comment">// 受scale影响</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">maolele</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/29/4-Unity%E4%B8%AD%E5%BF%85%E9%A1%BB%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E7%B1%BB/">http://example.com/2023/05/29/4-Unity%E4%B8%AD%E5%BF%85%E9%A1%BB%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E7%B1%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">maolele'blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</a></div><div class="post_share"><div class="social-share" data-image="/img/maolele.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/05/26/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84Python%E4%BE%BF%E6%8D%B7%E8%84%9A%E6%9C%AC/" title="游戏开发常用的Python便捷脚本"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">游戏开发常用的Python便捷脚本</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/26/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84Python%E4%BE%BF%E6%8D%B7%E8%84%9A%E6%9C%AC/" title="游戏开发常用的Python便捷脚本"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-26</div><div class="title">游戏开发常用的Python便捷脚本</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/maolele.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">maolele</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#unity%E4%B8%AD%E5%BF%85%E9%A1%BB%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">Unity中必须熟练掌握的几个类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#object"><span class="toc-number">1.1.</span> <span class="toc-text">Object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">实例化对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.3.</span> <span class="toc-text">删除对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#destroy"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">Destroy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#destroyimmdiate"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">DestroyImmdiate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dontdestroyonload"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">DontDestroyOnLoad</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monobehaviour"><span class="toc-number">1.2.</span> <span class="toc-text">MonoBehaviour</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96gameobject%E4%B8%8A%E6%8C%82%E8%BD%BD%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">获取GameObject上挂载的组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96gameobject%E4%B8%8A%E6%8C%82%E8%BD%BD%E7%9A%84%E5%8D%95%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">获取GameObject上挂载的单个组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96gameobject%E4%B8%8A%E6%8C%82%E8%BD%BD%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">获取GameObject上挂载的多个组件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%87%AA%E5%B7%B1%E4%BB%A5%E5%8F%8A%E5%AD%90%E5%AD%99%E7%89%A9%E4%BD%93%E4%B8%8A%E6%8C%82%E8%BD%BD%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">获取自己以及子孙物体上挂载的组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">获取单个组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">获取多个组件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%87%AA%E5%B7%B1%E4%BB%A5%E5%8F%8A%E7%88%B6%E7%89%A9%E4%BD%93%E5%8C%85%E6%8B%AC%E7%A5%96%E5%85%88%E4%B8%8A%E6%8C%82%E8%BD%BD%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">获取自己以及父物体(包括祖先)上挂载的组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8D%95%E4%B8%AA%E7%BB%84%E4%BB%B6-1"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">获取单个组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6-1"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">获取多个组件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96%E8%84%9A%E6%9C%AC"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">尝试获取脚本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gameobject"><span class="toc-number">1.3.</span> <span class="toc-text">GameObject</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">数据成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BE%9D%E9%99%84%E7%9A%84gameobject"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">获取依附的GameObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96gameobject%E7%9A%84transform%E7%BB%84%E4%BB%B6%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">获取GameObject的Transform组件相关信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%84%9A%E6%9C%AC%E4%BE%9D%E9%99%84%E7%9A%84gameobject%E6%98%AF%E5%90%A6%E6%BF%80%E6%B4%BB"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">获取脚本依附的GameObject是否激活</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96gameobject%E7%9A%84%E5%B1%82%E7%BA%A7%E5%92%8C%E6%A0%87%E7%AD%BE"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">获取GameObject的层级和标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6%E4%BE%9D%E9%99%84%E7%9A%84gameobject%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">获取其他组件依附的GameObject的信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%A0%E4%BD%95%E4%BD%93"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">创建几何体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BEgameobject"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">查找GameObject</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%8D%95%E4%B8%AAgameobject"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">查找单个GameObject</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%A4%9A%E4%B8%AAgameobject"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">查找多个GameObject</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.3.4.</span> <span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84gameobject"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">创建新的GameObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BAgameobject%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">为GameObject对象添加组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96gameobject%E4%B8%8A%E6%8C%82%E8%BD%BD%E7%9A%84%E7%BB%84%E4%BB%B6-1"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">获取GameObject上挂载的组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%E6%AF%94%E8%BE%83"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">标签比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%BF%80%E6%B4%BB%E5%A4%B1%E6%B4%BB"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">设置激活&#x2F;失活</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">广播&#x2F;消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#time"><span class="toc-number">1.4.</span> <span class="toc-text">Time</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%94%BE%E7%BC%A9%E6%AF%94%E4%BE%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">时间放缩比例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4"><span class="toc-number">1.4.2.</span> <span class="toc-text">帧间隔时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%A7%8B%E5%88%B0%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">1.4.3.</span> <span class="toc-text">游戏开始到现在的时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B8%A7%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4"><span class="toc-number">1.4.4.</span> <span class="toc-text">物理帧间隔时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%A7%8B%E5%88%B0%E7%8E%B0%E5%9C%A8%E7%9A%84%E5%B8%A7%E6%95%B0"><span class="toc-number">1.4.5.</span> <span class="toc-text">游戏开始到现在的帧数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transform"><span class="toc-number">1.5.</span> <span class="toc-text">Transform</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88-3"><span class="toc-number">1.5.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">1.5.2.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transform%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">1.5.3.</span> <span class="toc-text">Transform的常用属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BFgameobject%E8%BF%9B%E8%A1%8C%E4%BD%8D%E7%A7%BB"><span class="toc-number">1.5.4.</span> <span class="toc-text">使GameObject进行位移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%92%E5%BA%A6%E5%92%8C%E6%97%8B%E8%BD%AC"><span class="toc-number">1.5.5.</span> <span class="toc-text">角度和旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE%E5%92%8C%E7%9C%8B%E5%90%91"><span class="toc-number">1.5.6.</span> <span class="toc-text">缩放和看向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.7.</span> <span class="toc-text">父子关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E4%B8%8E%E6%9C%AC%E5%9C%B0%E5%9D%90%E6%A0%87%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.8.</span> <span class="toc-text">世界坐标与本地坐标的转换</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/29/4-Unity%E4%B8%AD%E5%BF%85%E9%A1%BB%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E7%B1%BB/" title="Unity中必须熟练掌握的几个类">Unity中必须熟练掌握的几个类</a><time datetime="2023-05-29T04:02:06.000Z" title="发表于 2023-05-29 12:02:06">2023-05-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/26/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84Python%E4%BE%BF%E6%8D%B7%E8%84%9A%E6%9C%AC/" title="游戏开发常用的Python便捷脚本">游戏开发常用的Python便捷脚本</a><time datetime="2023-05-26T14:33:29.000Z" title="发表于 2023-05-26 22:33:29">2023-05-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/26/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80-2/" title="链表之单链表基础(2)">链表之单链表基础(2)</a><time datetime="2023-05-26T14:03:01.000Z" title="发表于 2023-05-26 22:03:01">2023-05-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/26/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80-1/" title="链表之单链表基础(1)">链表之单链表基础(1)</a><time datetime="2023-05-26T11:38:22.000Z" title="发表于 2023-05-26 19:38:22">2023-05-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By maolele</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"left","width":145,"height":315,"hOffset":60,"vOffset":10},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>