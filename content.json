{"meta":{"title":"maolele'blog","subtitle":"","description":"","author":"maolele","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"链表之单链表","slug":"链表之单链表","date":"2023-05-26T11:38:22.000Z","updated":"2023-05-26T11:39:09.629Z","comments":true,"path":"2023/05/26/链表之单链表/","link":"","permalink":"http://example.com/2023/05/26/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"单链表 ​ 链表和顺序表一样，是一种线性表。但是单链表解决了顺序表需要预先设定表内存大小的问题，链表中的各个节点的内存都是按需分配的，这就使得链表非常灵活，需要存多少数据就创建多少个节点。另一方面，由于我们自己按需分配内存，所以导致链表在内存上不一定连续，具体分配到哪里的内存由操作系统决定。我们需要将这些分散的节点联系起来，这样我们才能方便地对它们进行遍历，而且，如果我们不把它们\"串\"起来，链表又怎么能是一种线性表呢？为了将各个节点\"串\"起来，我们为每个节点都增加一个区域——指针域，指针域存储下一个节点的地址，这样我们就能够通过前一个节点访问到下一个节点。这样的链表就是链表中最简单的单向链表。 单链表的结构 单链表的结构： 12345typedef struct Node&#123; int val; Node *next;&#125;Node; 在我们定义链表时，其实只需要定义一个指向首节点的指针，因为只要知道了链表中第一个节点的位置，后面所有的节点都可以通过各个节点的指针域来依次获取。 1Node *pHead = NULL; 单链表的创建 对于创建，最常见的就是根据某数据的个数创建、根据某个数行创建和根据另一个链表进行创建。 先看看最简单的，根据某数据的个数进行创建。 由于创建链表的操作势必会修改指向首节点的指针本身，所以，我们要么把首节点的地址通过返回值返回并对指向首节点的指针进行赋值，要么通过二级指针来修改指向首节点的指针(如果使用的是C++，可以使用引用来修改指针本身，参数为Node *&amp;pHead)。 另外，每次新创建的新节点可以插入在链表的头部也可插入在链表的尾部。如果插入在头部，则最终的顺序和插入的顺序正好相反，例如建表时依次创建1,2,3,4,5，创建完成后，链表从前到后的元素依次为5,4,3,2,1。而尾插则最终链表节点的顺序与新建节点的顺序一致。 这里，我们通过函数参数来传递指向首节点的指针，在插入时使用头插法： 123456789101112131415161718192021void CreateListByVal(Node **ppHead, int val, int num)&#123; *ppHead = NULL; for(int i = 0; i &lt; num; ++i) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = NULL; // 头插 if(NULL == *ppHead) &#123; *ppHead = pNew; &#125; else &#123; pNew-&gt;next = *ppHead; *ppHead = pNew; &#125; &#125;&#125; 根据数组创建链表，使用尾插法： 由于每次需要插入到链表的尾部，需要知道尾部在哪，所以我们要定义一个尾指针，它始终指向末尾节点。 123456789101112131415161718192021222324// 根据数组[begin, end)范围的元素创建链表void CreateListByArr(Node **ppHead, int *begin, int *end)&#123; *ppHead = NULL; Node *pRear = NULL; // 尾指针 while(begin &lt; end) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = *begin; pNew-&gt;next = NULL; // 尾插 if(NULL == *ppHead) &#123; *ppHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; ++begin; &#125;&#125; 最后，根据另一个链表创建新的链表： 123456789101112131415161718192021222324void CreateListByList(Node **ppHead, const Node *pOther)&#123; *ppHead = NULL; Node *pRear = NULL; while(pOther != NULL) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = pOther-&gt;val; pNew-&gt;next = NULL; if(NULL == *ppHead) &#123; *ppHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; pOther = pOther-&gt;next; &#125;&#125; 单链表的插入 无论是插入还是删除，我们都需要先找到插入/删除位置的前一个节点位置。如果是直接找到要插入/删除的位置，而没有记录前一个位置，那么我们就无法把前一个位置的节点与后面的节点\"串\"起来，链表就断了。 另外，由于我们创建的链表是不带头节点的，在首个位置插入元素和在其它位置插入元素的逻辑不一样，导致我们需要对这些不同的情况分开判断。 (我们所有的例子，链表的索引都是从1开始的) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int InsertList(Node **ppHead, int val, int pos)&#123; if(pos &lt; 1) return ERROR; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = NULL; if(NULL == *ppHead) // 链表为空 &#123; *ppHead = pNew; return OK; &#125; else if(pos &lt; 2) // pos = 1, 新节点作为首节点 &#123; pNew-&gt;next = (*ppHead)-&gt;next; *ppHead = pNew; return OK; &#125; else &#123; // 找到插入位置的前一个位置pos-1 Node *p = *ppHead; // pos &lt;= 2 =&gt; pos == 2: 找到插入位置的前一个位置 // NULL == p-&gt;next: 遍历到链表尾节点时仍未找到要插入的前一个位置 while(pos &gt; 2 &amp;&amp; p != NULL) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1位置, 且pos-1位置的节点存在 if(p != NULL) &#123; pNew-&gt;next = p-&gt;next; p-&gt;next = pNew; return OK; &#125; else &#123; free(pNew); return ERROR; &#125; &#125;&#125; 单链表的删除 根据索引pos进行删除(pos从1开始)： 123456789101112131415161718192021222324252627282930313233343536int DelList(Node **ppHead, int pos)&#123; if(NULL == *ppHead || pos &lt; 1) return ERROR; if(1 == pos) // 删除链表首节点 &#123; Node *pTemp = *ppHead; *ppHead = pTemp-&gt;next; free(pTemp); return OK; &#125; else &#123; Node *p = *ppHead; // 查找pos-1位置的节点 while(pos &gt; 2 &amp;&amp; p-&gt;next != NULL) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1的位置且存在pos位置的节点 if(p-&gt;next != NULL) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); pTemp = NULL; return OK; &#125; else &#123; return ERROR; &#125; &#125;&#125; 单链表的清空 123456789void ClearList(Node **ppHead)&#123; while(*ppHead != NULL) &#123; Node *pTemp = (*ppHead)-&gt;next; free(*ppHead); *ppHead = pTemp; &#125;&#125; 单链表的遍历 123456789void PrintList(const Node *pHead)&#123; while(pHead != NULL) &#123; printf(&quot;%d &quot;, pHead-&gt;val); pHead = pHead-&gt;next; &#125; printf(&quot;\\n&quot;);&#125; 删除单链表中所有值为val的节点 ​ 需要注意删除首个节点和删除后续节点的操作不一样，需分别考虑。 123456789101112131415161718192021222324252627282930313233void DelListByVal(Node **ppHead, int val)&#123; if(NULL == *ppHead) return; // 删除值为val的首元素 while(*ppHead != NULL &amp;&amp; (*ppHead)-&gt;val == val) &#123; Node *pTemp = *ppHead; *ppHead = pTemp-&gt;next; free(pTemp); &#125; // 首元素存在且值不为val if(*ppHead == NULL) return; Node *p = *ppHead; while(p-&gt;next != NULL) &#123; if(p-&gt;next-&gt;val == val) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); // 删除了p后面的结点后, 不需要挪动p指针 // 因为被删除节点的后一个节点重新成为了p指向的下一个节点 // 继续判断即可 &#125; else &#123; p = p-&gt;next; &#125; &#125;&#125; 对单链表进行冒泡排序 ​ 冒泡排序每一趟冒泡都是从第一个元素开始的，而不带哑节点的单链表中起始两个节点的交换操作和其他位置相邻两个节点的交换操作的逻辑不一样(起始两个节点在交换时，这两个节点前面没有任何节点，要将头指针重新指向交换操作后的第一个节点) ​ 为了使得交换起始两个节点与交换后续相邻节点的操作保持一致(保持一致后，便于编写循环)，需要创建一个临时的哑节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void SortList(Node **ppHead)&#123; int nodeNum = 0; Node *p = *ppHead; while(p != NULL) &#123; p = p-&gt;next; ++nodeNum; &#125; // 将一个哑节点作为链表的第一个节点, 便于操作 Node dummyNode; dummyNode.next = *ppHead; *ppHead = p = &amp;dummyNode; // printf(&quot;begin sort:\\n&quot;); for(int i = 0; i &lt; nodeNum; ++i) &#123; for(int j = 0; j &lt; nodeNum - i - 1; ++j) &#123; // printf(&quot;(%d and %d)\\n&quot;, p-&gt;next-&gt;val, p-&gt;next-&gt;next-&gt;val); // PrintList((*ppHead)-&gt;next); // 判断p2后的两个节点是否需要交换 if(p-&gt;next-&gt;val &gt; p-&gt;next-&gt;next-&gt;val) &#123; // a, b, c, d // a: p的位置 // b: pTemp1的位置 // d: pTemp3的位置 Node *pTemp1 = p-&gt;next; Node *pTemp3 = p-&gt;next-&gt;next-&gt;next; p-&gt;next = p-&gt;next-&gt;next; p-&gt;next-&gt;next = pTemp1; p-&gt;next-&gt;next-&gt;next = pTemp3; &#125; p = p-&gt;next; &#125; // printf(&quot;\\n&quot;); p = &amp;dummyNode; &#125; // 将头指针重新指向存储实际数据的第一个节点 *ppHead = dummyNode.next;&#125; 删除已序单链表中值重复的节点 ​ 由于是已序的单链表，所以可以一次遍历就能完成去重。 ​ 使用两个指针，一个快指针，一个慢指针，指向链表中的相邻两个节点，判断数据是否重复，若重复则删除快指针指向的节点，慢指针无需移动，只需将快指针移动到被删除节点的下一个节点，继续判断。若不重复则使快指针和慢指针同时往后挪一位。 123456789101112131415161718192021222324void DelSortedListDuplicate(Node **ppHead)&#123; Node *pSlow = *ppHead; Node *pPrev = pSlow-&gt;next; // printf(&quot;begin del dup\\n&quot;); while(pPrev != NULL) &#123; if(pSlow-&gt;val == pPrev-&gt;val) &#123; Node *pTemp = pPrev; pSlow-&gt;next = pPrev-&gt;next; free(pTemp); pPrev = pSlow-&gt;next; // 删除后, pSlow不动, pPrev移动到被删除节点的下一个节点 &#125; else &#123; pSlow = pSlow-&gt;next; pPrev = pPrev-&gt;next; &#125; // PrintList(*ppHead); &#125;&#125; 将之前写的所有操作在C++中用类进行封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367#include &lt;iostream&gt;template&lt;typename T&gt;class LinkedList&#123;private: struct Node &#123; T val; Node *next; &#125;; Node *pHead;public: LinkedList(); LinkedList(T val, int num); LinkedList(T *begin, T *end); LinkedList(const LinkedList &amp;list); bool Insert(T val, int pos); bool DeleteByPos(int pos); void DeleteByVal(T val); void Sort(); void DelSortedDuplicate(); void Print(); int Length(); void Clean();&#125;;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList()&#123; pHead = nullptr;&#125;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList(T val, int num): pHead(nullptr)&#123; for(int i = 0; i &lt; num; ++i) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = nullptr; // 头插 if(nullptr == pHead) &#123; pHead = pNew; &#125; else &#123; pNew-&gt;next = pHead; pHead = pNew; &#125; &#125;&#125;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList(T *begin, T *end): pHead(nullptr)&#123; Node *pRear = nullptr; // 尾指针 while(begin &lt; end) &#123; // std::cout &lt;&lt; &quot;create: &quot; &lt;&lt; *begin &lt;&lt; std::endl; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = *begin; pNew-&gt;next = nullptr; // 尾插 if(nullptr == pHead) &#123; pHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; ++begin; &#125;&#125;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList(const LinkedList &amp;list): pHead(nullptr)&#123; Node *pRear = nullptr; while(list.pHead != nullptr) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = list.pHead-&gt;val; pNew-&gt;next = nullptr; if(nullptr == *pHead) &#123; *pHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; list.pHead = list.pHead-&gt;next; &#125;&#125;template&lt;typename T&gt;int LinkedList&lt;T&gt;::Length()&#123; int len = 0; Node *p = pHead; while(p != nullptr) &#123; ++len; p = p-&gt;next; &#125; return len;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::Print()&#123; Node *p = pHead; while(p != nullptr) &#123; printf(&quot;%d &quot;, p-&gt;val); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;template&lt;typename T&gt;bool LinkedList&lt;T&gt;::Insert(T val, int pos)&#123; if(pos &lt; 1) return false; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = nullptr; if(nullptr == pHead) // 链表为空 &#123; pHead = pNew; return true; &#125; else if(pos &lt; 2) // pos = 1, 新节点作为首节点 &#123; pNew-&gt;next = pHead-&gt;next; pHead = pNew; return true; &#125; else &#123; // 找到插入位置的前一个位置pos-1 Node *p = pHead; // pos &lt;= 2 =&gt; pos == 2: 找到插入位置的前一个位置 // NULL == p-&gt;next: 遍历到链表尾节点时仍未找到要插入的前一个位置 while(pos &gt; 2 &amp;&amp; p != nullptr) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1位置, 且pos-1位置的节点存在 if(p != nullptr) &#123; pNew-&gt;next = p-&gt;next; p-&gt;next = pNew; return true; &#125; else &#123; free(pNew); return false; &#125; &#125;&#125;template&lt;typename T&gt;bool LinkedList&lt;T&gt;::DeleteByPos(int pos)&#123; if(nullptr == pHead || pos &lt; 1) return false; if(1 == pos) // 删除链表首节点 &#123; Node *pTemp = pHead; pHead = pTemp-&gt;next; free(pTemp); return true; &#125; else &#123; Node *p = pHead; // 查找pos-1位置的节点 while(pos &gt; 2 &amp;&amp; p-&gt;next != nullptr) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1的位置且存在pos位置的节点 if(p-&gt;next != nullptr) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); pTemp = NULL; return true; &#125; else &#123; return false; &#125; &#125;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::DeleteByVal(T val)&#123; if(nullptr == pHead) return; // 删除值为val的首元素 while(pHead != nullptr &amp;&amp; pHead-&gt;val == val) &#123; Node *pTemp = pHead; pHead = pTemp-&gt;next; free(pTemp); &#125; // 首元素存在且值不为val if(nullptr == pHead) return; Node *p = pHead; while(p-&gt;next != nullptr) &#123; if(p-&gt;next-&gt;val == val) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); // 删除了p后面的结点后, 不需要挪动p指针 // 因为被删除节点的后一个节点重新成为了p指向的下一个节点 // 继续判断即可 &#125; else &#123; p = p-&gt;next; &#125; &#125;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::Sort()&#123; int nodeNum = 0; Node *p = pHead; while(p != NULL) &#123; p = p-&gt;next; ++nodeNum; &#125; // 将一个哑节点作为链表的第一个节点, 便于操作 Node dummyNode; dummyNode.next = pHead; pHead = p = &amp;dummyNode; // printf(&quot;begin sort:\\n&quot;); for(int i = 0; i &lt; nodeNum; ++i) &#123; for(int j = 0; j &lt; nodeNum - i - 1; ++j) &#123; // printf(&quot;(%d and %d)\\n&quot;, p-&gt;next-&gt;val, p-&gt;next-&gt;next-&gt;val); // PrintList((*ppHead)-&gt;next); // 判断p2后的两个节点是否需要交换 if(p-&gt;next-&gt;val &gt; p-&gt;next-&gt;next-&gt;val) &#123; // a, b, c, d // a: p2的位置 // b: pTemp1的位置 // c: pTemp2的位置 Node *pTemp1 = p-&gt;next; Node *pTemp3 = p-&gt;next-&gt;next-&gt;next; p-&gt;next = p-&gt;next-&gt;next; p-&gt;next-&gt;next = pTemp1; p-&gt;next-&gt;next-&gt;next = pTemp3; &#125; p = p-&gt;next; &#125; // printf(&quot;\\n&quot;); p = &amp;dummyNode; &#125; pHead = dummyNode.next;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::DelSortedDuplicate()&#123; Node *pSlow = pHead; Node *pPrev = pSlow-&gt;next; // printf(&quot;begin del dup\\n&quot;); while(pPrev != NULL) &#123; if(pSlow-&gt;val == pPrev-&gt;val) &#123; Node *pTemp = pPrev; pSlow-&gt;next = pPrev-&gt;next; free(pTemp); pPrev = pSlow-&gt;next; // 删除后, pSlow不动, pPrev移动到被删除节点的下一个节点 &#125; else &#123; pSlow = pSlow-&gt;next; pPrev = pPrev-&gt;next; &#125; // Print(); &#125;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::Clean()&#123; while(pHead != nullptr) &#123; Node *pTemp = pHead-&gt;next; free(pHead); pHead = pTemp; &#125;&#125;int main()&#123; int arr[10] = &#123;1, 8, 4, 4, 5, 5, 7, 8, 5, 10&#125;; LinkedList&lt;int&gt; list(&amp;arr[0], &amp;arr[10]); list.Print(); std::cout &lt;&lt; &quot;length of list: &quot; &lt;&lt; list.Length() &lt;&lt; std::endl; list.Insert(100, 5); list.Print(); list.DeleteByPos(1); list.Print(); list.DeleteByVal(8); list.Print(); list.Sort(); list.Print(); list.DelSortedDuplicate(); list.Print(); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}