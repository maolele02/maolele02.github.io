{"meta":{"title":"maolele'blog","subtitle":"","description":"","author":"maolele","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"游戏开发常用的Python便捷脚本","slug":"游戏开发常用的Python便捷脚本","date":"2023-05-26T14:33:29.000Z","updated":"2023-05-27T12:07:33.749Z","comments":true,"path":"2023/05/26/游戏开发常用的Python便捷脚本/","link":"","permalink":"http://example.com/2023/05/26/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84Python%E4%BE%BF%E6%8D%B7%E8%84%9A%E6%9C%AC/","excerpt":"","text":"游戏开发常用的Python便捷脚本 需要用到的Python库：Pillow； Pillow的安装： 1$ pip3 install pillow 图片分割器 ​ 例如，现有一张大小为128*128px的纹理图，该纹理图中包含了16个32*32px大小的独立部分，我们有时会希望把这些独立部分都拆分出来，将这些32*32px的内容分别单独提取出来成为一张独立的图片。 123456789101112131415161718192021222324252627282930313233343536# split.py# 将一张图按slice_size*slice_size的尺寸切成多个小块import osimport argparsefrom PIL import Imageif __name__ == &quot;__main__&quot;: parse = argparse.ArgumentParser() parse.add_argument(&quot;--tilesheet&quot;, type=str, required=True, help=&quot;tilesheet image path&quot;) parse.add_argument(&quot;--slicesize&quot;, type=int, required=False, default=32) args = parse.parse_args() image_path = args.tilesheet slice_size = args.slicesize now_path = os.getcwd() result_path = now_path + &quot;\\\\out&quot; if not os.path.exists(result_path): os.mkdir(result_path) img = Image.open(image_path) w, h = img.size print(&quot;the tilesheet&#x27;s size: %d*%d&quot; % (w, h)) complete = 1 for row in range(0, h, slice_size): for col in range(0, w, slice_size): # print(&quot;pos:(%d, %d)&quot; % (row, col)) slice_img = img.crop((row, col, row + slice_size, col + slice_size)) path = result_path + &quot;\\\\&quot; slice_img.save(&quot;%s%d.png&quot; % (path, complete)) complete += 1 print(&quot;complete, total %d slice image.&quot; % complete) 使用： 1$ python split.py --tilesheet input.png --slicesize 32 未完待续...","categories":[],"tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"}]},{"title":"链表之单链表基础(2)","slug":"链表之单链表基础-2","date":"2023-05-26T14:03:01.000Z","updated":"2023-05-27T12:07:16.842Z","comments":true,"path":"2023/05/26/链表之单链表基础-2/","link":"","permalink":"http://example.com/2023/05/26/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80-2/","excerpt":"","text":"链表之单链表基础(2) 合并两个升序链表 例如： list1 = [2, 5, 7, 8, 12]，list2 = [1, 6, 7, 10, 11]，合并后为list = [1 2 5 6 7 7 8 10 11 12]。 ​ 我们可以用一个指针指向已合并链表的末尾节点，用另外两个指针分别指向当前需要进行比较合并操作的两个节点，这两个指针可以直接使用传入的两个指针参数：两个升序链表的头节点指针。 ​ 当list1-&gt;val &lt; list2-&gt;val时，我们将 list1指向的节点连接到p指向的节点的下一个节点，然后p和list1后往后挪动一个位置，再继续比较。反之同理。 ​ 合并到最后的情况可能是其中某个链表已为NULL，这时只需将另外一个非空的链表接到p所指节点的后面即可。 ​ 为了统一合并链表起始位置节点和后续位置节点的逻辑，创建一个哑节点，一开始将p指针指向该哑节点，然后再进行比较合并操作。 123456789101112131415161718192021222324Node *MergeTwoLists(Node *list1, Node *list2)&#123; Node dummyNode = &#123;-1, NULL&#125;; Node *p = &amp;dummyNode; while(list1 != NULL &amp;&amp; list2 != NULL) &#123; if(list1-&gt;val &lt; list2-&gt;val) &#123; p-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; p-&gt;next = list2; list2 = list2-&gt;next; &#125; p = p-&gt;next; &#125; p-&gt;next = NULL == list1 ? list2 : list1; return dummyNode.next;&#125; 时间复杂度：O(n+m)，n和m为两个链表的长度； 空间复杂度：O(1) 判断链表是否有环 ​ 如果链表中有环，则不存在有指针域为NULL的节点。如果链表中无环，则链表末尾节点的指针域为NULL。 ​ 判断链表是否有环，最直观的逻辑就是遍历链表，如果遇到了之前遍历过的节点，就说明有环，如果遍历到NULL，则说明无环。为了能够快速判断遍历的节点是否在之前已遍历过，用哈希表存储所有已遍历节点的地址。具体逻辑如下： ​ 对链表进行遍历，在遍历时判断当前节点是否存在于哈希表中，若不存在则将该节点的地址存入哈希表，若存在则表明当前是第二次访问该节点，说明链表中存在环，返回TRUE。在遍历的过程中，若用于遍历的指针为NULL，则说明已到链表末尾，该链表无环，返回FALSE。 ​ 具体代码略。 时间复杂度：O(n)，n为链表的长度； 空间复杂度：O(n)，n为链表的长度，因为需要用到哈希表，哈希表中存储各个节点的地址。 也可以使用floyd判圈算法(龟兔赛跑法)。 ​ 我们可以让快指针和慢指针一开始都指向第一个节点。在循环中，慢指针每次移动一步，而快指针每次移动2步。 ​ 如果链表中无环，在出发后，快指针始终跑在慢指针的前面，直至快指针到点链表末尾，(NULL == pFast || NULL == pFast-&gt;next)判断条件成立，返回FALSE。 ​ 如果链表中有环，则快指针进入环后，会持续在环中兜圈，这样一来，快指针和慢指针必然会在某一次循环中相遇，判断到相遇后，我们就返回TRUE。 相遇情况举例： ​ 假设链表的长度为N，链表末尾节点接到了起始节点，形成一个环链表。在开始赛跑之前，快慢指针都指向起始节点，此时，快指针距离追上慢指针还差N步。每跑一轮，距离N = N-1，所以至多跑N轮后快慢指针再次相遇。 123456789101112131415161718192021222324// floyd判圈int HasCircle(Node *pHead)&#123; if(NULL == pHead || NULL == pHead-&gt;next) &#123; return FALSE; &#125; Node *pSlow = pHead, *pFast = pHead; do &#123; if(NULL == pFast || NULL == pFast-&gt;next) &#123; return FALSE; &#125; pSlow = pSlow-&gt;next; pFast = pFast-&gt;next-&gt;next; &#125;while(pSlow != pFast); return TRUE;&#125; 时间复杂度：O(n)，n为链表的长度； 空间复杂度：O(1) 相交链表 ​ 给定两个链表(非环链表)，找出并返回这两个链表相交的起始节点，如果两个链表不存在相交的节点，则返回NULL。 ​ 同样地，该题也可以用哈希表来记录已访问过的节点。先遍历第一个链表，将该链表的所有节点的地址存储到哈希表中。再遍历第一个链表，在遍历的同时判断当前遍历的节点是否已存在于哈希表中，若已存在则说明该节点在之前访问过，即这个节点是两个链表的相交节点。 ​ 具体代码略。 时间复杂度：O(m+n)，m和n为链表的长度； 空间复杂度：O(m)，m是第一个被遍历的链表长度。 ​ 双指针法： LinkedList 我们可以观察相交链表，可以发现相交链表分为三个部分： A链表中不相交的部分，该部分的节点数设为a； B链表中不相交的部分，该部分的节点数设为b； A、B链表相交的部分，该部分的节点数设为c。 如此划分，则A链表的长度为：m = a + c，B链表的长度为：n = b + c。所以，当a = b时，m = n。 ​ 当c=0时，就是A、B两个链表不相交的情况。这里我们不能根据c = 0判断链表是否相交，因为如果根据这一条件判断的话，那岂不是又是之前使用哈希表的方法？之前我们使用哈希表完成判断链表是否相交的本质就是在找两个链表中是否存在同一个节点。我们需要知道同一个节点有多少个才能知道c的值是多少，想要A、B两个链表中完全相同的节点有多少个就又得去记录......所以不根据c = 0进行判断。 先考虑最容易想的情况，那就是a = b的情况： ​ 对于这种情况，我们会很直观的想到可以用两个指针pA和pB来同时遍历A、B两个链表。 ​ 若是相交链表，则pA和pB一定能同时到达第一个相交的节点。所以我们可以在每次移动pA和pB之前判断两个指针所指节点的地址是否相等，若相等则说明两个链表一定相交。 ​ 若不是相交链表，则pA和pB会同时到达A、B链表的尾节点(不相交也就是c=0，a=b，那么m=n嘛)。也就是说，在遍历的过程中，pA和pB会同时为NULL。所以，\"直到pA和pB同时为NULL也还没找到地址相同的节点\"可以作为链表不相交的条件。 再考虑一般情况，a != b(即m != n)： ​ 对于这种情况，按之前的方法显然是不能使pA和pB同时指向第一个相交节点的，所以不对之前的方法进行修改而直接使用是行不通的。既然我们是因为pA和pB不能同时到达第一个相交节点而无法判断链表是否相交，那么我们可以想想办法怎么让pA和pB可以同时到达第一个相交的节点。 所以我们需要再次对a != b的情况进行观察。 ​ 既然m = a + c, n = b + c，为了使pA和pB能够同时遍历到第一个相交的节点，应该寻找某个互补相等的条件。那么这样互补一下？m + b = n + a。根据这个公式，我们可以得出方案，pA和pB中的某个指针若到达了链表末尾，也就是说值为NULL了，那么我们就让它从另一个链表的头部重新进行遍历。这样一来，因为m + b = n + a，所以如果我们让pA和pB一直遍历下去的话，它们迟早会同时遍历到对方链表的末尾，若是相交链表，则是同时遍历到相交部分的末尾。对于相交链表，既然能够同时遍历到相交部分的末尾，那这不就说明了能够同时遍历到第一个相交的节点嘛！所以，问题就这样解决了。 12345678910111213141516171819202122232425262728293031323334Node *GetIntersectionNode(Node *list1, Node *list2)&#123; if(NULL == list1 || NULL == list2) &#123; return NULL; &#125; // 两个用于遍历的指针 Node *pList1 = list1, *pList2 = list2; // 进行遍历 while(pList1 != pList2) // pList1和pList2相等时退出遍历 &#123; if(NULL == pList1) // pList1 == NULL, pList2 != NULL &#123; pList1 = list2; // 移动到另一个链表的头部 pList2 = pList2-&gt;next; // pList2不为空, 继续往后遍历 &#125; else if(NULL == pList2) // pList1 != NULL, pLsit2 == NULL &#123; pList2 = list1; pList1 = pList1-&gt;next; &#125; else // pList1和pList2都不为空 &#123; pList1 = pList1-&gt;next; pList2 = pList2-&gt;next; &#125; &#125; // 若是相交链表, 此处返回的就是第一个相交节点的地址 // 若不是相交链表, 此处返回的是NULL(pList1和pList2同时遍历到对方链表的末尾) return pList1;&#125; 可以用三目运算符稍作改进： 1234567891011121314151617Node *GetIntersectionNode(Node *list1, Node *list2)&#123; if(NULL == list1 || NULL == list2) &#123; return NULL; &#125; Node *pList1 = list1, *pList2 = list2; while(pList1 != pList2) &#123; pList1 = NULL == pList1 ? list2 : pList1-&gt;next; pList2 = NULL == pList2 ? list1 : pList2-&gt;next; &#125; return pList1;&#125; 时间复杂度：O(m+n)，m和n是两个链表的长度； 空间复杂度：O(1)。 反转链表 ​ 在遍历链表时，将当前节点的指针域改为指向前一个节点。由于单链表的节点中没有指向前一个节点的指针域，所以需要事先存储该节点的前一个节点的地址。 ​ 在更改指针域之前还需要存储后一个节点的地址，以便在修改后将当前节点移动到下一个节点。 123456789101112void ReverseList(Node **ppHead)&#123; Node *p = NULL; while(NULL != *ppHead) &#123; Node *next = (*ppHead)-&gt;next; (*ppHead)-&gt;next = p; p = *ppHead; *ppHead = next; &#125; *ppHead = p;&#125; 时间复杂度：O(n)，n是链表的长度； 空间复杂度：O(1) 回文链表 ​ 由于单链表中的节点只有指向下一个节点的指针域，不能直接根据链表判断回文。 ​ 一种思路是先将链表中各个节点的值按顺序存储到数组中，然后利用双指针法对数组进行回文判断。 ​ 具体代码略。 时间复杂度：O(n)，n是链表的长度； 空间复杂度：O(n)，n是链表的长度，因为至少需要长度为n的数组来存储链表中各个节点的数据。 ​ 另一种思路是，先将链表的后半部分进行反转，这样就可以对链表使用双指针从两端向内依次判断了。在完成判断后再重新将后半部分的链表再次进行反转，将链表恢复回原先的链表。这个方法的缺点是在多线程并发的情况下不安全。 时间复杂度：O(n)，n是链表的长度； 空间复杂度：O(1)。 123456789101112131415161718192021222324252627282930313233343536373839404142// 反转链表struct ListNode *ReverseList(Node *pHead)&#123; Node *p = NULL; while(NULL != pHead) &#123; Node *next = pHead-&gt;next; pHead-&gt;next = p; p = pHead; pHead = next; &#125; return p;&#125;// 判断回文链表bool IsPalindrome(Node* head)&#123; if(NULL == head) return true; // 使用快慢指针找到链表的中间节点 Node *pSlow = head, *pFast = head; while(NULL != pFast-&gt;next &amp;&amp; NULL != pFast-&gt;next-&gt;next) &#123; pSlow = pSlow-&gt;next; pFast = pFast-&gt;next-&gt;next; &#125; Node *pRear = ReverseList(pSlow-&gt;next); int result = 1; while(result &amp;&amp; NULL != pRear) &#123; if(head-&gt;val != pRear-&gt;val) &#123; result = 0; &#125; head = head-&gt;next; pRear = pRear-&gt;next; &#125; // 恢复后半部分的链表 pSlow-&gt;next = ReverseList(pRear); return result;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"链表之单链表基础(1)","slug":"链表之单链表基础-1","date":"2023-05-26T11:38:22.000Z","updated":"2023-05-27T08:56:12.598Z","comments":true,"path":"2023/05/26/链表之单链表基础-1/","link":"","permalink":"http://example.com/2023/05/26/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80-1/","excerpt":"","text":"链表之单链表基础(1) ​ 链表和顺序表一样，是一种线性表。但是链表解决了顺序表需要预先设定表内存大小的问题，链表中的各个节点的内存都是按需分配的，这就使得链表非常灵活，需要存多少数据就创建多少个节点。另一方面，由于我们自己按需分配内存，所以导致链表在内存上不一定连续，具体分配到哪里的内存由操作系统决定。我们需要将这些分散的节点联系起来，这样我们才能方便地对它们进行遍历，而且，如果我们不把它们\"串\"起来，链表又怎么能是一种线性表呢？为了将各个节点\"串\"起来，我们为每个节点都增加一个区域——指针域，指针域存储下一个节点的地址，这样我们就能够通过前一个节点访问到下一个节点。这样的链表就是链表中最简单的单向链表。 单链表的结构 单链表的结构： 12345typedef struct Node&#123; int val; Node *next;&#125;Node; 在我们定义链表时，其实只需要定义一个指向首节点的指针，因为只要知道了链表中第一个节点的位置，后面所有的节点都可以通过各个节点的指针域来依次获取。 1Node *pHead = NULL; 由于C99之前没有bool数据类型，使用宏来定义布尔值： 12345#define OK 0;#define ERROR 1;#define TRUE 1;#define FALSE 0; 单链表的创建 对于创建，最常见的就是根据某数据的个数创建、根据某个数行创建和根据另一个链表进行创建。 先看看最简单的，根据某数据的个数进行创建。 由于创建链表的操作势必会修改指向首节点的指针本身，所以，我们要么把首节点的地址通过返回值返回并对指向首节点的指针进行赋值，要么通过二级指针来修改指向首节点的指针(如果使用的是C++，可以使用引用来修改指针本身，参数为Node *&amp;pHead)。 另外，每次新创建的新节点可以插入在链表的头部也可插入在链表的尾部。如果插入在头部，则最终的顺序和插入的顺序正好相反，例如建表时依次创建1,2,3,4,5，创建完成后，链表从前到后的元素依次为5,4,3,2,1。而尾插则最终链表节点的顺序与新建节点的顺序一致。 这里，我们通过函数参数来传递指向首节点的指针，在插入时使用头插法： 123456789101112131415161718192021void CreateListByVal(Node **ppHead, int val, int num)&#123; *ppHead = NULL; for(int i = 0; i &lt; num; ++i) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = NULL; // 头插 if(NULL == *ppHead) &#123; *ppHead = pNew; &#125; else &#123; pNew-&gt;next = *ppHead; *ppHead = pNew; &#125; &#125;&#125; 根据数组创建链表，使用尾插法： 由于每次需要插入到链表的尾部，需要知道尾部在哪，所以我们要定义一个尾指针，它始终指向末尾节点。 123456789101112131415161718192021222324// 根据数组[begin, end)范围的元素创建链表void CreateListByArr(Node **ppHead, int *begin, int *end)&#123; *ppHead = NULL; Node *pRear = NULL; // 尾指针 while(begin &lt; end) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = *begin; pNew-&gt;next = NULL; // 尾插 if(NULL == *ppHead) &#123; *ppHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; ++begin; &#125;&#125; 最后，根据另一个链表创建新的链表： 123456789101112131415161718192021222324void CreateListByList(Node **ppHead, const Node *pOther)&#123; *ppHead = NULL; Node *pRear = NULL; while(pOther != NULL) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = pOther-&gt;val; pNew-&gt;next = NULL; if(NULL == *ppHead) &#123; *ppHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; pOther = pOther-&gt;next; &#125;&#125; 单链表的插入 无论是插入还是删除，我们都需要先找到插入/删除位置的前一个节点位置。如果是直接找到要插入/删除的位置，而没有记录前一个位置，那么我们就无法把前一个位置的节点与后面的节点\"串\"起来，链表就断了。 另外，由于我们创建的链表是不带头节点的，在首个位置插入元素和在其它位置插入元素的逻辑不一样，导致我们需要对这些不同的情况分开判断。 (我们所有的例子，链表的索引都是从1开始的) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int InsertList(Node **ppHead, int val, int pos)&#123; if(pos &lt; 1) return ERROR; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = NULL; if(NULL == *ppHead) // 链表为空 &#123; *ppHead = pNew; return OK; &#125; else if(pos &lt; 2) // pos = 1, 新节点作为首节点 &#123; pNew-&gt;next = (*ppHead)-&gt;next; *ppHead = pNew; return OK; &#125; else &#123; // 找到插入位置的前一个位置pos-1 Node *p = *ppHead; // pos &lt;= 2 =&gt; pos == 2: 找到插入位置的前一个位置 // NULL == p-&gt;next: 遍历到链表尾节点时仍未找到要插入的前一个位置 while(pos &gt; 2 &amp;&amp; p != NULL) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1位置, 且pos-1位置的节点存在 if(p != NULL) &#123; pNew-&gt;next = p-&gt;next; p-&gt;next = pNew; return OK; &#125; else &#123; free(pNew); return ERROR; &#125; &#125;&#125; 单链表的删除 根据索引进行删除 根据索引pos进行删除：(索引pos从1开始)： 123456789101112131415161718192021222324252627282930313233343536int DelList(Node **ppHead, int pos)&#123; if(NULL == *ppHead || pos &lt; 1) return ERROR; if(1 == pos) // 删除链表首节点 &#123; Node *pTemp = *ppHead; *ppHead = pTemp-&gt;next; free(pTemp); return OK; &#125; else &#123; Node *p = *ppHead; // 查找pos-1位置的节点 while(pos &gt; 2 &amp;&amp; p-&gt;next != NULL) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1的位置且存在pos位置的节点 if(p-&gt;next != NULL) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); pTemp = NULL; return OK; &#125; else &#123; return ERROR; &#125; &#125;&#125; 根据数值进行删除 删除链表中所有值为val的节点： 需要注意删除首个节点和删除后续节点的操作不一样，需分别考虑。 123456789101112131415161718192021222324252627282930313233void DelListByVal(Node **ppHead, int val)&#123; if(NULL == *ppHead) return; // 删除值为val的首元素 while(*ppHead != NULL &amp;&amp; (*ppHead)-&gt;val == val) &#123; Node *pTemp = *ppHead; *ppHead = pTemp-&gt;next; free(pTemp); &#125; // 首元素存在且值不为val if(*ppHead == NULL) return; Node *p = *ppHead; while(p-&gt;next != NULL) &#123; if(p-&gt;next-&gt;val == val) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); // 删除了p后面的结点后, 不需要挪动p指针 // 因为被删除节点的后一个节点重新成为了p指向的下一个节点 // 继续判断即可 &#125; else &#123; p = p-&gt;next; &#125; &#125;&#125; 可以看到，由于删除第一个节点和删除后续节点的操作不一致，导致实现起来非常不方便，所以可以创建一个哑节点来统一操作： 123456789101112131415161718192021void DelListByVal(Node **ppHead, int val)&#123; Node dummyNode = &#123;-1, *ppHead&#125;; *ppHead = &amp;dummyNode; while((*ppHead)-&gt;next != NULL) &#123; if((*ppHead)-&gt;next-&gt;val == val) &#123; Node *pTemp = (*ppHead)-&gt;next; (*ppHead)-&gt;next = pTemp-&gt;next; free(pTemp); &#125; else &#123; (*ppHead) = (*ppHead)-&gt;next; &#125; &#125; *ppHead = dummyNode.next;&#125; 实际上，这种使用哑节点统一操作的方式比分别考虑不同情况的方式的效率高。既方便，效率又高，何乐而不为？ 单链表的清空 123456789void ClearList(Node **ppHead)&#123; while(*ppHead != NULL) &#123; Node *pTemp = (*ppHead)-&gt;next; free(*ppHead); *ppHead = pTemp; &#125;&#125; 单链表的遍历 123456789void PrintList(const Node *pHead)&#123; while(pHead != NULL) &#123; printf(&quot;%d &quot;, pHead-&gt;val); pHead = pHead-&gt;next; &#125; printf(&quot;\\n&quot;);&#125; 对单链表进行冒泡排序 ​ 冒泡排序每一趟冒泡都是从第一个元素开始的，而不带哑节点的单链表中起始两个节点的交换操作和其他位置相邻两个节点的交换操作的逻辑不一样(起始两个节点在交换时，这两个节点前面没有任何节点，要将头指针重新指向交换操作后的第一个节点) ​ 为了使得交换起始两个节点与交换后续相邻节点的操作保持一致(保持一致后，便于编写循环)，需要创建一个临时的哑节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void SortList(Node **ppHead)&#123; int nodeNum = 0; Node *p = *ppHead; while(p != NULL) &#123; p = p-&gt;next; ++nodeNum; &#125; // 将一个哑节点作为链表的第一个节点, 便于操作 Node dummyNode; dummyNode.next = *ppHead; *ppHead = p = &amp;dummyNode; // printf(&quot;begin sort:\\n&quot;); for(int i = 0; i &lt; nodeNum; ++i) &#123; for(int j = 0; j &lt; nodeNum - i - 1; ++j) &#123; // printf(&quot;(%d and %d)\\n&quot;, p-&gt;next-&gt;val, p-&gt;next-&gt;next-&gt;val); // PrintList((*ppHead)-&gt;next); // 判断p2后的两个节点是否需要交换 if(p-&gt;next-&gt;val &gt; p-&gt;next-&gt;next-&gt;val) &#123; // a, b, c, d // a: p的位置 // b: pTemp1的位置 // d: pTemp3的位置 Node *pTemp1 = p-&gt;next; Node *pTemp3 = p-&gt;next-&gt;next-&gt;next; p-&gt;next = p-&gt;next-&gt;next; p-&gt;next-&gt;next = pTemp1; p-&gt;next-&gt;next-&gt;next = pTemp3; &#125; p = p-&gt;next; &#125; // printf(&quot;\\n&quot;); p = &amp;dummyNode; &#125; // 将头指针重新指向存储实际数据的第一个节点 *ppHead = dummyNode.next;&#125; 删除已序单链表中值重复的节点 ​ 由于是已序的单链表，所以可以一次遍历就能完成去重。 ​ 使用两个指针，一个快指针，一个慢指针，指向链表中的相邻两个节点，判断数据是否重复，若重复则删除快指针指向的节点，慢指针无需移动，只需将快指针移动到被删除节点的下一个节点，继续判断。若不重复则使快指针和慢指针同时往后挪一位。 123456789101112131415161718192021222324void DelSortedListDuplicate(Node **ppHead)&#123; Node *pSlow = *ppHead; Node *pPrev = pSlow-&gt;next; // printf(&quot;begin del dup\\n&quot;); while(pPrev != NULL) &#123; if(pSlow-&gt;val == pPrev-&gt;val) &#123; Node *pTemp = pPrev; pSlow-&gt;next = pPrev-&gt;next; free(pTemp); pPrev = pSlow-&gt;next; // 删除后, pSlow不动, pPrev移动到被删除节点的下一个节点 &#125; else &#123; pSlow = pSlow-&gt;next; pPrev = pPrev-&gt;next; &#125; // PrintList(*ppHead); &#125;&#125; 将之前写的所有操作在C++中用类进行封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367#include &lt;iostream&gt;template&lt;typename T&gt;class LinkedList&#123;private: struct Node &#123; T val; Node *next; &#125;; Node *pHead;public: LinkedList(); LinkedList(T val, int num); LinkedList(T *begin, T *end); LinkedList(const LinkedList &amp;list); bool Insert(T val, int pos); bool DeleteByPos(int pos); void DeleteByVal(T val); void Sort(); void DelSortedDuplicate(); void Print(); int Length(); void Clean();&#125;;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList()&#123; pHead = nullptr;&#125;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList(T val, int num): pHead(nullptr)&#123; for(int i = 0; i &lt; num; ++i) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = nullptr; // 头插 if(nullptr == pHead) &#123; pHead = pNew; &#125; else &#123; pNew-&gt;next = pHead; pHead = pNew; &#125; &#125;&#125;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList(T *begin, T *end): pHead(nullptr)&#123; Node *pRear = nullptr; // 尾指针 while(begin &lt; end) &#123; // std::cout &lt;&lt; &quot;create: &quot; &lt;&lt; *begin &lt;&lt; std::endl; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = *begin; pNew-&gt;next = nullptr; // 尾插 if(nullptr == pHead) &#123; pHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; ++begin; &#125;&#125;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList(const LinkedList &amp;list): pHead(nullptr)&#123; Node *pRear = nullptr; while(list.pHead != nullptr) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = list.pHead-&gt;val; pNew-&gt;next = nullptr; if(nullptr == *pHead) &#123; *pHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; list.pHead = list.pHead-&gt;next; &#125;&#125;template&lt;typename T&gt;int LinkedList&lt;T&gt;::Length()&#123; int len = 0; Node *p = pHead; while(p != nullptr) &#123; ++len; p = p-&gt;next; &#125; return len;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::Print()&#123; Node *p = pHead; while(p != nullptr) &#123; printf(&quot;%d &quot;, p-&gt;val); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;template&lt;typename T&gt;bool LinkedList&lt;T&gt;::Insert(T val, int pos)&#123; if(pos &lt; 1) return false; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = nullptr; if(nullptr == pHead) // 链表为空 &#123; pHead = pNew; return true; &#125; else if(pos &lt; 2) // pos = 1, 新节点作为首节点 &#123; pNew-&gt;next = pHead-&gt;next; pHead = pNew; return true; &#125; else &#123; // 找到插入位置的前一个位置pos-1 Node *p = pHead; // pos &lt;= 2 =&gt; pos == 2: 找到插入位置的前一个位置 // NULL == p-&gt;next: 遍历到链表尾节点时仍未找到要插入的前一个位置 while(pos &gt; 2 &amp;&amp; p != nullptr) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1位置, 且pos-1位置的节点存在 if(p != nullptr) &#123; pNew-&gt;next = p-&gt;next; p-&gt;next = pNew; return true; &#125; else &#123; free(pNew); return false; &#125; &#125;&#125;template&lt;typename T&gt;bool LinkedList&lt;T&gt;::DeleteByPos(int pos)&#123; if(nullptr == pHead || pos &lt; 1) return false; if(1 == pos) // 删除链表首节点 &#123; Node *pTemp = pHead; pHead = pTemp-&gt;next; free(pTemp); return true; &#125; else &#123; Node *p = pHead; // 查找pos-1位置的节点 while(pos &gt; 2 &amp;&amp; p-&gt;next != nullptr) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1的位置且存在pos位置的节点 if(p-&gt;next != nullptr) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); pTemp = NULL; return true; &#125; else &#123; return false; &#125; &#125;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::DeleteByVal(T val)&#123; if(nullptr == pHead) return; // 删除值为val的首元素 while(pHead != nullptr &amp;&amp; pHead-&gt;val == val) &#123; Node *pTemp = pHead; pHead = pTemp-&gt;next; free(pTemp); &#125; // 首元素存在且值不为val if(nullptr == pHead) return; Node *p = pHead; while(p-&gt;next != nullptr) &#123; if(p-&gt;next-&gt;val == val) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); // 删除了p后面的结点后, 不需要挪动p指针 // 因为被删除节点的后一个节点重新成为了p指向的下一个节点 // 继续判断即可 &#125; else &#123; p = p-&gt;next; &#125; &#125;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::Sort()&#123; int nodeNum = 0; Node *p = pHead; while(p != NULL) &#123; p = p-&gt;next; ++nodeNum; &#125; // 将一个哑节点作为链表的第一个节点, 便于操作 Node dummyNode; dummyNode.next = pHead; pHead = p = &amp;dummyNode; // printf(&quot;begin sort:\\n&quot;); for(int i = 0; i &lt; nodeNum; ++i) &#123; for(int j = 0; j &lt; nodeNum - i - 1; ++j) &#123; // printf(&quot;(%d and %d)\\n&quot;, p-&gt;next-&gt;val, p-&gt;next-&gt;next-&gt;val); // PrintList((*ppHead)-&gt;next); // 判断p后的两个节点是否需要交换 if(p-&gt;next-&gt;val &gt; p-&gt;next-&gt;next-&gt;val) &#123; // a, b, c, d // a: p2的位置 // b: pTemp1的位置 // c: pTemp2的位置 Node *pTemp1 = p-&gt;next; Node *pTemp3 = p-&gt;next-&gt;next-&gt;next; p-&gt;next = p-&gt;next-&gt;next; p-&gt;next-&gt;next = pTemp1; p-&gt;next-&gt;next-&gt;next = pTemp3; &#125; p = p-&gt;next; &#125; // printf(&quot;\\n&quot;); p = &amp;dummyNode; &#125; pHead = dummyNode.next;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::DelSortedDuplicate()&#123; Node *pSlow = pHead; Node *pPrev = pSlow-&gt;next; // printf(&quot;begin del dup\\n&quot;); while(pPrev != nullptr) &#123; if(pSlow-&gt;val == pPrev-&gt;val) &#123; Node *pTemp = pPrev; pSlow-&gt;next = pPrev-&gt;next; free(pTemp); pPrev = pSlow-&gt;next; // 删除后, pSlow不动, pPrev移动到被删除节点的下一个节点 &#125; else &#123; pSlow = pSlow-&gt;next; pPrev = pPrev-&gt;next; &#125; // Print(); &#125;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::Clean()&#123; while(pHead != nullptr) &#123; Node *pTemp = pHead-&gt;next; free(pHead); pHead = pTemp; &#125;&#125;int main()&#123; int arr[10] = &#123;1, 8, 4, 4, 5, 5, 7, 8, 5, 10&#125;; LinkedList&lt;int&gt; list(&amp;arr[0], &amp;arr[10]); list.Print(); std::cout &lt;&lt; &quot;length of list: &quot; &lt;&lt; list.Length() &lt;&lt; std::endl; list.Insert(100, 5); list.Print(); list.DeleteByPos(1); list.Print(); list.DeleteByVal(8); list.Print(); list.Sort(); list.Print(); list.DelSortedDuplicate(); list.Print(); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[],"tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}