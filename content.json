{"meta":{"title":"maolele'blog","subtitle":"","description":"","author":"maolele","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Unity中必须熟练掌握的几个类","slug":"4-Unity中必须熟练掌握的几个类","date":"2023-05-29T04:02:06.000Z","updated":"2023-05-29T04:03:06.994Z","comments":true,"path":"2023/05/29/4-Unity中必须熟练掌握的几个类/","link":"","permalink":"http://example.com/2023/05/29/4-Unity%E4%B8%AD%E5%BF%85%E9%A1%BB%E7%86%9F%E7%BB%83%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E7%B1%BB/","excerpt":"","text":"Unity中必须熟练掌握的几个类 Unity中必须熟练掌握的几个类： GameObject Component Transform MonoBehaviour 另外，还需要熟悉： Object：UnityEngine中所有的类都派生于UnityEngine.Object Time 常用类的继承关系： 所有类的最远父类都是Object； GameObject、Component、Texture、Mesh、Material都直接由Object派生而来； Transform、Rigidbody、ParticleSystem、Behaviour、Collider、Renderer都派生于Component，它们都是组件； MonoBehaviour、Camera、Animator、AudioSource、Light、Animation、AudioListener都派生于Behaviour； 我们游戏开发人员自己编写的脚本，若想挂载到游戏对象上，须继承MonoBehaviour。 ​ 我们的脚本继承了MonoBehaviour后，可以直接在脚本中使用父类中所有的public、protected成员，另外，因为MonoBehaviour的上层父类继承了Component，所以我们我们的脚本对象也是一种组件。 Object UnityEngine.Object的所有成员参看：Unity - Scripting API: Object (unity3d.com) 概览 属性 hideFlags name 公有方法 GetInstanceID ToString 静态方法 Destroy DestroyImmediate DontDestroyOnLoad FindAnyObjectByType FindFirstObjectByType FindObjectsByTeype FindObjectsOfType Instantiate 实例化对象 根据一个GameObject对象的引用复制出一个新的对象： 1GameObject obj = Instantiate(myObj); 删除对象 Destroy Destroy()方法调用后并不会立即删除对象，一般情况会在下一帧中从内存中删除。 1234GameObject.Destroy(obj);// 第二个参数：延迟几秒删除GameObject.Destroy(obj5, 5); DestroyImmdiate 使用DestroyImmdiate()方法可以立即删除对象。一般情况下不使用这个方法，如果在同一帧中大量调用该方法销毁对象，可能会导致游戏卡顿。 1GameObject.DestroyImmediate(obj); DontDestroyOnLoad 默认情况下，在切换场景时，之前场景中的对象会自动被删除。如果不希望某个对象在切换场景时被删除，可以使用DontDestroyOnLoad()方法。 12// 在下面的方法中传入想在过场景时保留的对象DontDestroyOnLoad(this.gameObject); // 设置自己依附的GameObject过场景不被删除 MonoBehaviour MonoBehaviour的所有成员参看：Unity - Scripting API: MonoBehaviour (unity3d.com) 概览 属性 runInEditMode useGUILayout 公有方法 CancelInvoke Invoke InvokeRepeating IsInvoking StartCoroutine StopAllCoroutines StopCoroutine 静态方法 print：向控制台打印输出，该方法调用了Debug.Log()，功能完全一样，仅仅是为了再次封装，调用起来更方便； 消息(Messages) Awake Start FixedUpdate Update LateUpdate ... 这些消息都是Unity的生命周期函数 MonoBehaviour派生于Behaviour，而Behaviour又派生于Component，所以Behaviour和Component中存在的属性、方法，在MonoBehaviour中也存在； 在Behaviour类中定义了两个属性： enable isActiveAndEnabled 下面列出一些继承了MonoBehaviour的类中可以执行的操作，不单独讲是Behaviour的还是Component类的。 数据成员 当前脚本继承了MonoBehaviour类，而MonoBehaviour的父类Component中有一个gameObject属性： 1public GameObject gameObject&#123; get; &#125; 它是当前脚本(组件)所依附的GameObject对象。 所以我们可以在当前脚本中直接使用gameObject来获取脚本所依附的GameObject对象。 另外，GameObject类中还有其他组件类型的属性： 1public Componet transform &#123; get; &#125; 这些父类中的这些属性存储了对应组件对象的引用，所以我们可以直接在脚本中使用。 123print(this.transform.position);// GameObject类中也也有transform属性print(this.gameObject.transform.position); // 与上面本质是一样的 设置当前脚本的激活/失活： 1this.enabled = false; 获取其他脚本所依附的GameObject的信息： 12345678910111213141516using System.Collections;using System.Collections.Generic;using UnityEngine;public class Script2 : MonoBehaviour&#123; // 此处的Script1也是一个继承了MonoBehaviour的脚本 // 在编辑器中使用拖拽赋值 public Script1 otherScript; void Start() &#123; print(otherScript.gameObject.name); print(otherScript.transform.position); &#125;&#125; 成员方法 下面是一些用于获取当前脚本对象所依附的GameObject对象所挂载的组件的方法。 这些方法在GameObject类中也有。 获取GameObject上挂载的组件 获取GameObject上挂载的单个组件 通过组件名获取： 1Test t = this.GetComponent(&quot;Test&quot;) as Test; 通过组件类型获取： 1Test t = this.GetComponent(typeof(Test)) as Test; 通过泛型获取，这是最常用的一种方式： 1Test t = this.GetComponent&lt;Test&gt;(); 上面这些方法如果获取失败，则返回null。 如果GameObject上挂载了多个同类型的组件，我们通过上面的方法获取该类型的组件，无法确定最终获取到的具体是哪一个组件。 获取GameObject上挂载的多个组件 根据泛型获取，组件对象的引用存储至数组，并返回： 1Test[] arrary = this.GetComponents&lt;Test&gt;(); 根据泛型获取，将list作为参数传入，组件对象的引用存储至list中。 12List&lt;Test&gt; list = new List&lt;Test&gt;();this.GetComponents&lt;Test&gt;(list); 获取自己以及子孙物体上挂载的组件 获取单个组件 123// 得到子物体上挂载的组件(默认也会找自身上是否挂载该组件)// 参数true：失活的物体也进行查找(默认为false，只查找激活的物体)Test t = this.GetComponentInChilder&lt;Test&gt;(true); 获取多个组件 12345// 得到子物体挂载的多个组件(默认也会找自身上是否挂载该组件)Test[] arr = this.GetComponentsInChildren&lt;Test&gt;(true);List&lt;Test&gt; list = new List&lt;Test&gt;();this.GetComponentsInChildren&lt;Test&gt;(true, list); 获取自己以及父物体(包括祖先)上挂载的组件 获取单个组件 1Test t = this.GetComponentInParent&lt;Test&gt;(); 获取多个组件 1234Test[] arr = this.GetComponentsInParent&lt;Test&gt;();List&lt;Test&gt; list = new List&lt;Test&gt;();this.GetComponentsInParent&lt;Test&gt;(list); 尝试获取脚本 使用TryGetComponent&lt;ComponentType&gt;()函数获取组件对象，参数是out类型的参数，返回值是bool类型。 123456Test test;if(this.TryGetComponent&lt;Test&gt;(out test))&#123; // 逻辑处理 // ...&#125; GameObject GameObject的所有成员参看：Unity - Scripting API: GameObject (unity3d.com) 概览 属性 activeInHierarchy activeSelf isStatic layer scene sceneCullingMask tag：Component类中也有 transform：Component类中也有 可以看到，除了Component类中的属性，除了没有gameObject属性以外，其他的属性在GameObject中也同样有。 公有方法 AddComponent BroadcastMessage：Component类中也有 CompareTag：Component类中也有 GetComponent：Component类中也有 GetComponentInChildern：Component类中也有 GetComponentInParent：Component类中也有 GetComponents：Component类中也有 GetComponentsInChildren：Component类中也有 GetComponetsInParent：Component类中也有 SendMessage：Component类中也有 SendMessageUpwards：Component类中也有 SetActive TryGetComponent：Component类中也有 可以看到，Component类中所有的公有方法，在GameObject类中也有，但GameObject并不派生于Component； 为什么要在Component类中也定义这些获取组件的方法？ 从逻辑上讲，获取组件获取的是某一个游戏物体的组件，应该把获取组件相关的方法定义在游戏物体的类中，而组件的类中不需要定义； 我们自己编写的脚本，在挂载后创建的脚本对象，它也是一种组件。我们编写的游戏逻辑是写在脚本中的，在脚本中常常需要获取脚本所依附的游戏物体上的其他组件，所以需要在Component类中定义获取组件相关的方法。 静态方法 CreatePrimitive Find FindGameObjectsWithTag FindWithTag GameObject类继承了Object类，所以还拥有了Object中有所的公有、静态方法。 数据成员 获取依附的GameObject 父类MonoBehaviour中定义了只读属性gameObject，其值为当前脚本对象依附的GameObject的引用。 123this.gameObject;this.gameObject.name; // string类型this.gameObject.name = &quot;LiHua&quot;; 获取GameObject的Transform组件相关信息 1234this.transform.position; // 位置this.transform.eulerAngles; // 角度this.transform.lossyScale; // 缩放大小this.gameObject.transform; 获取脚本依附的GameObject是否激活 1234// 游戏对象是否激活this.gameObject.activateSelf;// 游戏对象是否静态(static)this.gameObject.isStatic; 获取GameObject的层级和标签 1234// 层级this.gameObject.layer; // 返回的是int类型的值// 标签this.gameObject.tag; // 返回的是一个字符串 获取其他组件依附的GameObject的信息 12345678910111213using System.Collections;using System.Collections.Generic;using UnityEngine;public class Test : MonoBehaviour&#123; public Test otherTest; void Start() &#123; print(otherTest.gameObject.name); print(otherTest.transform.position); &#125;&#125; 静态方法 创建几何体 12345678910111213141516171819using System.Collections;using System.Collections.Generic;using UnityEngine;public class Test : MonoBehaviour&#123; // 准备用来克隆的对象 // 1. 可以是场景上的某个对象 // 2. 可以是一个预制体对象 public GameObject myObj; void Start() &#123; // 创建几何体 // 参数是枚举类型: // Capsule, Cube, Cylinder, Plane, Quad, Sphere myObj = GameObject.CreatePrimitive(PrimitiveType.Cube); &#125;&#125; 查找GameObject 查找单个GameObject 通过对象名查找： 12// 通过对象名查找(这种查找效率较低，会在场景中的所有对象去查找),未找到则返回nullGameObject obj = GameObject.Find(&quot;啊哈&quot;); 通过tag查找： 12345// 通过tag查找对象GameObject obj1 = GameObject.FindWithTag(&quot;Player&quot;);// 下面这个方法与上面的方法只是方法名字的区别GameObject obj2 = GameObject.FindGameObjectWithTag(&quot;Player&quot;); 前面两种查找游戏物体对象的方法的共同点： 只能查找激活的对象； 当前场景中如果有多个满足条件的对象，则无法确定最终找到的具体是哪个对象。 另外，我们可以使用UnityEngine.Object类提供的静态方法FindObjectOfType&lt;ComponentType&gt;()等，先获取组件对象，再根据组件对象获取其依附的GameObject对象。但是这样的效率非常低，它不仅要要遍历场景中的对象，还需要遍历对象上的组件。 12Test test = GameObject.FindObjectOfType&lt;Test&gt;();print(test.gameObject.name); 查找多个GameObject 找多个对象的API只能是通过tag查找多个,通过名字不能查找多个： 12// 通过tag找多个对象(只能找到激活的对象，无法找到失活的对象)GameObject[] objs = GameObject.FindGameObjectsWithTag(&quot;Player&quot;); 成员方法 创建新的GameObject 直接new GameObject()即可，创建之后，该游戏物体就会存在于游戏场景中。 12345678910GameObject obj = new GameObject();GameObject obj = new GameObject(&quot;name&quot;); // 可以通过传递第一个参数来设置物体的name// 可以在创建物体的同时给物体添加组件GameObjcet obj8 = new GameObjcet(&quot;创建空物体并挂载一个脚本&quot;, typeof(Component1), typeof(Component2) ); 为GameObject对象添加组件 1234// 为对象添加组件Test test1 = obj.addComponent(typeof(Test)) as Test;// 用泛型更方便Test test2 = obj.AddComponent&lt;Test&gt;(); 获取GameObject上挂载的组件 同Component类中的那些获取组件的方法。 标签比较 123bool flag = this.gameObject.CompareTag(&quot;Player&quot;);// 或:bool flag = this.gameObject.tag == &quot;Player&quot;; 设置激活/失活 1obj.SetActive(false); // 设置失活 广播/消息 通知GameObject执行名为某个函数名的方法： 123obj.SendMessage(&quot;TestFun1&quot;);// 第二个及后面的所有参数作为要调用的方法的实参obj.SendMessage(&quot;TestFun2&quot;, 666); 该功能会在GameObject自己身上挂载的所有组件中去找这个名字的方法，所以该方法的执行效率比较低。通常不使用该方法，一般都是先获取对应的组件，然后在通过该组件来调用组件对应的方法，下面的两个方法也是同理。 通知当前GameObject自己以及该GameObject的子物体执行某个方法： 1obj.BroadcastMessage(&quot;FuncName&quot;); 通知当前GameObject自己以及该GameObject的父物体执行某个方法： 1obj.SendMessageUpwards(&quot;FuncName&quot;); Time UnityEngine命名空间中的Time包含了更时间相关的API。Time类中的所有成员都是静态的属性，因此，可以直接通过类名进行调用。 时间放缩比例 123Time.timeScale = 0; // 时间停止Time.timeScale = 2; // 时间变为2倍Time.timeScale = 1; // 正常的时间比例 帧间隔时间 帧间隔时间指的是执行当前这行代码的时间与上一帧中执行这行代码的时间的间隔。帧间隔时间的单位为秒。 123Time.deltaTime; // 受Time.timeScale影响// Time.deltaTime = Time.unscaleDeltaTime * Time.timeScale;Time.unscaleDeltaTime; // 不受Time.timeScale影响 帧间隔时间主要用来计算位移。平均路程=时间*平均速度。 假设，现在需要让某个物体在每帧中移动一次： 1234void Update() &#123; transform.Translate(0, 0, distancePerFrame);&#125; ​ 由于Update的调用受帧率的影响，在需要大量渲染时，Update的调用间隔较大，在渲染量较小时，Update调用的间隔较小，另外Update的调用还受硬件配置的影响。所以上述代码并不能保证物体是匀速移动的。 ​ 所以需要使用Time.deltaTime来缩放当前帧需移动到的距离： 1234void Update()&#123; transform.Translate(0, 0, distancePerFrame * Time.deltaTime);&#125; 游戏开始到现在的时间 游戏运行到现在的时间常用于单机游戏，在网络游戏中，时间是以服务器的时间为准的。 12Time.time; // 游戏开始运行到现在的时间(受Time.scale影响)Time.unscaledTime; // 不受Time.scale影响 物理帧间隔时间 物理帧间隔时间默认为0.02s，物理帧间隔时间在游戏运行的整个过程中都是固定的。 12Time.fixedDeltaTime; // 物理帧间隔时间(受Time.scale影响)Time.fixedUnscaleDeltaTime; // 不受Time.scale影响 游戏开始到现在的帧数 1Time.frameCount; Transform Transform的所有成员参看：Unity - Scripting API: Transform (unity3d.com) 概览 属性 childCount eulerAngles：欧拉角 localEulerAngles forword localPosition localRotation localScale parent position right root rotation up ... 公有方法 LookAt Roate RotateAround Translate ​ 游戏对象(GameObject)的位移、旋转、缩放、父子关系、坐标转换等相关操作都由Transform对象管理的。 Vector 在学习Transform相关成员之前，需要先了解Vector。 Vector3三维向量，Vector2是二维向量。 Vector3的三个属性x, y, z是三维向量的三个坐标。 12Vector2 v1 = new Vector2(1, 2);Vector3 v2 = new Vector3(1, 2, 3); Vector实现了+、-、*、/的运算符重载。 123456Vector3 v1 = new Vector3(1, 1， 1);Vector3 v12 = new Vector3(2, 2， 2);print(v1 + v12); // (3.0, 3.0, 3.0)print(v1 - v12); // (-1.0, -1.0, -1.0)print(v1 * 10); // (10.0, 10.0, 10.0)print(v12 / 2); // (1.0, 1.0, 1.0) 常用的向量： 12345678print(Vector3.zero); // (0.0, 0.0, 0.0)print(Vector3.right); // (1.0, 0.0, 0.0)print(Vector3.left); // (-1.0, 0.0, 0.0)print(Vector3.forward); // (0.0, 0.0, 1.0)print(Vector3.back); // (0.0, 0.0, -1.0)print(Vector3.up); // (0.0, 1.0, 0.0)print(Vector3.down); // (0.0, -1.0, 0.0)print(Vector3.one); // (1.0, 1.0, 1.0) 计算两个向量之间的距离： 1Vector3.Distance(v1, v12); Transform的常用属性 位置信息： 12transform.position; // 相对于世界坐标系transform.localPosition; // 相对于父物体(如果没有父物体,则与transform.position相同) transform.position和transform.localPosition的x, y, z都是只读属性，不可赋值。如果想要修改position，可以对其重新赋一个向量： 12transform.position = new Vector3(10, 10, 10);transform.localPosition = Vector3.up * 10; 游戏物体当前的朝向： 1234567// 物体当前的面朝向transform.forward;// 物体当前的头顶朝向transform.up;// 物体当前的右手边transform.right;// 其他同理 使GameObject进行位移 计算位移： 位移 = 速度 * 时间； 而速度又包含的速率和方向，只有知道了这三者才能正确的将游戏物体进行位移。 12345float speed = 10;// 往游戏物体自己的面朝向移动transform.position += transform.forward * speed * Time.deltaTime;// 往世界坐标系的Z轴方向移动transform.position += Vector3.forward * speed * Time.deltaTime; 我们还可以调用transform.Translate()方法来实现同样的效果。 1234567891011// 参数1：位移// 参数2：相对的坐标系;该参数默认是相对于物体自己的坐标系// 相对于世界坐标系朝z轴移动this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World);// 相对于世界坐标系让物体朝自己的面朝向移动this.transform.Translate(this.transform.forward * 1 * Time.deltaTime, Space.World);// 相对于自己的坐标系下的z轴正方向移动(始终朝自己的面朝向移动)this.transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.Self); 角度和旋转 欧拉角： transform.localEulerAngles获取的欧拉角就是Inspector窗口中Transform的Rotation显示的数据(相对于父对象的欧拉角)。 12transform.eulerAngles; // 相对于世界坐标系transform.localEulerAngles; // 相对于父物体 与transform.position一样，不能单独修改其x, y, z，若要修改需要重新赋一个Vector3对象，后面的缩放比例也是一样。 自转： 1234// 每个轴具体转多少度// 参数1：每帧x, y, z轴方向旋转的角度// 参数2：默认相对于自己坐标系进行的旋转transform.Rotate(new Vector3(0, 10, 0) * Time.deltaTime, Space.Self); 绕轴旋转： 1234// 参数1：相对于哪轴进行转动// 参数2：转动的角度// 参数3：默认相对于自己的坐标系进行旋转transform.Rotate(Vector3.up, 10 * Time.deltaTime, Space.World); 绕某点旋转(类似于地球绕太阳公转)： 12345// 相对于某一个点转// 参数1：相对于哪一个点// 参数2：相对于哪一个点的哪一个轴// 参数3：转的度数 旋转速度 * 时间this.transform.RotateAround(Vector3.zero, Vector3.up, 10 * Time.deltaTime); 缩放和看向 缩放比例： 123456// 相对于世界坐标系transform.lossyScale;// 相对于本地坐标系(父物体)transform.localScale;transform.localScale = new Vector3(3, 3, 3); 看向： 让GameObject对象的面朝向(物体的Z轴方向)看向某一个点或某一个对象(都是相对于世界坐标系)。 12345// 看向一个点// 该方法还有第二个参数, 是在旋转时相对于哪个轴进行旋转, 默认为y轴transform.LookAt(Vector3.zero);// 看向一个对象(传入一个对象的Transform信息)transform.LookAt(otherTransform); 父子关系 获取父物体GameObject： 1transform.parent; 父物体是可以修改的： 123456789// 设置当前GameObject无父物体transform.parent = null;// 或:transform.SetParent(null);// 让otherTransform依附的GameObject作为当前GameObject的父物体transform.parent = otherTransform;// 或:transform.SetParent(otherTransform); transform.SetParent(Transform parent, bool worldPositionStays)的参数： 参数1：父物体的transform； 参数2：是否保留世界坐标的位置、角度、缩放比例，默认为 true； 为true：当子物体的位置、角度、缩放比例会根据父物体对应的值进行计算。例如： 父物体的position: 10, 10, 10, localScale: 2, 2, 2，子物体的position: 0, 0, 0, localScale: 1, 1, 1。取消该父物体后，子物体的position: 10, 10, 10, localScale: 2, 2, 2。使得该子物体在解除父子关系后相对于世界坐标系的大小、位置、角度都不变。 为false：当某物体成为另外一个物体的子物体时，直接把原先相对于世界坐标系的坐标设为相对于父物体的坐标，没有根据父物体的信息进行计算，所以在成为子物体后，其相对于世界坐标系的位置、大小、旋转可能会发生改变。 解除所有的子物体(不影响子孙之间的父子关系)： 1transform.DetachChildren(); 获取子物体： transform.Find()查找不包括孙物体，只能找自己下一级的子物体；查找效率比GameObject.Find()高。 123456// 按子物体的name进行查找(可查找失活的子物体)transform.Find(&quot;Cube (1)&quot;);// 按子物体索引号获取子物体// 如果索引超出子物体索引的范围, 则会报错Transform t = transform.GetChild(0); 获取子物体的个数： transform.childCount不包括孙物体的个数。 1transform.childCount; // 包括激活和失活的子物体 判断自身是否是某个物体的子物体： 1trans.IsChildOf(OtherTransform); 获取自身作为子物体的索引： 1trans.GetSiblingIndex(); 将自己设置为父物体的第一个子物体： 1trans.SetAsFirstSibling(); 将自己设为父物体的最后一个子物体： 1trans.SetAsLastSibling(); 将自己设置为指定索引的子物体： 12// 当索引超出范围时会设置为索引范围内的最后一个索引trans.SetSiblingIndex(6); 世界坐标与本地坐标的转换 世界坐标系的坐标转换为本地坐标坐标： 1transform.InverseTransformPoint(Vector3.forward); 世界坐标系的方向转换本地坐标系的方向： 12transform.InverseTransfromDirection(Vector3.forward); // 不受scale影响transform.InverseTransformVector(Vector3.forward); // 受scale影响 本地坐标系坐标转换为世界坐标系坐标： 12transform.TransformPoint(Vector3.forward); // 不受scale影响transform.TransformVector(Vector3.forward); // 受scale影响","categories":[],"tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"}]},{"title":"游戏开发常用的Python便捷脚本","slug":"游戏开发常用的Python便捷脚本","date":"2023-05-26T14:33:29.000Z","updated":"2023-05-27T12:07:33.749Z","comments":true,"path":"2023/05/26/游戏开发常用的Python便捷脚本/","link":"","permalink":"http://example.com/2023/05/26/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84Python%E4%BE%BF%E6%8D%B7%E8%84%9A%E6%9C%AC/","excerpt":"","text":"游戏开发常用的Python便捷脚本 需要用到的Python库：Pillow； Pillow的安装： 1$ pip3 install pillow 图片分割器 ​ 例如，现有一张大小为128*128px的纹理图，该纹理图中包含了16个32*32px大小的独立部分，我们有时会希望把这些独立部分都拆分出来，将这些32*32px的内容分别单独提取出来成为一张独立的图片。 123456789101112131415161718192021222324252627282930313233343536# split.py# 将一张图按slice_size*slice_size的尺寸切成多个小块import osimport argparsefrom PIL import Imageif __name__ == &quot;__main__&quot;: parse = argparse.ArgumentParser() parse.add_argument(&quot;--tilesheet&quot;, type=str, required=True, help=&quot;tilesheet image path&quot;) parse.add_argument(&quot;--slicesize&quot;, type=int, required=False, default=32) args = parse.parse_args() image_path = args.tilesheet slice_size = args.slicesize now_path = os.getcwd() result_path = now_path + &quot;\\\\out&quot; if not os.path.exists(result_path): os.mkdir(result_path) img = Image.open(image_path) w, h = img.size print(&quot;the tilesheet&#x27;s size: %d*%d&quot; % (w, h)) complete = 1 for row in range(0, h, slice_size): for col in range(0, w, slice_size): # print(&quot;pos:(%d, %d)&quot; % (row, col)) slice_img = img.crop((row, col, row + slice_size, col + slice_size)) path = result_path + &quot;\\\\&quot; slice_img.save(&quot;%s%d.png&quot; % (path, complete)) complete += 1 print(&quot;complete, total %d slice image.&quot; % complete) 使用： 1$ python split.py --tilesheet input.png --slicesize 32 未完待续...","categories":[],"tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"}]},{"title":"链表之单链表基础(2)","slug":"链表之单链表基础-2","date":"2023-05-26T14:03:01.000Z","updated":"2023-05-28T05:15:20.710Z","comments":true,"path":"2023/05/26/链表之单链表基础-2/","link":"","permalink":"http://example.com/2023/05/26/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80-2/","excerpt":"","text":"链表之单链表基础(2) 合并两个升序链表 例如： list1 = [2, 5, 7, 8, 12]，list2 = [1, 6, 7, 10, 11]，合并后为list = [1 2 5 6 7 7 8 10 11 12]。 ​ 我们可以用一个指针指向已合并链表的末尾节点，用另外两个指针分别指向当前需要进行比较合并操作的两个节点，这两个指针可以直接使用传入的两个指针参数：两个升序链表的头节点指针。 ​ 当list1-&gt;val &lt; list2-&gt;val时，我们将 list1指向的节点连接到p指向的节点的下一个节点，然后p和list1后往后挪动一个位置，再继续比较。反之同理。 ​ 合并到最后的情况可能是其中某个链表已为NULL，这时只需将另外一个非空的链表接到p所指节点的后面即可。 ​ 为了统一合并链表起始位置节点和后续位置节点的逻辑，创建一个哑节点，一开始将p指针指向该哑节点，然后再进行比较合并操作。 123456789101112131415161718192021222324Node *MergeTwoLists(Node *list1, Node *list2)&#123; Node dummyNode = &#123;-1, NULL&#125;; Node *p = &amp;dummyNode; while(list1 != NULL &amp;&amp; list2 != NULL) &#123; if(list1-&gt;val &lt; list2-&gt;val) &#123; p-&gt;next = list1; list1 = list1-&gt;next; &#125; else &#123; p-&gt;next = list2; list2 = list2-&gt;next; &#125; p = p-&gt;next; &#125; p-&gt;next = NULL == list1 ? list2 : list1; return dummyNode.next;&#125; 时间复杂度：O(n+m)，n和m为两个链表的长度； 空间复杂度：O(1) 判断链表是否有环 ​ 如果链表中有环，则不存在有指针域为NULL的节点。如果链表中无环，则链表末尾节点的指针域为NULL。 ​ 判断链表是否有环，最直观的逻辑就是遍历链表，如果遇到了之前遍历过的节点，就说明有环，如果遍历到NULL，则说明无环。为了能够快速判断遍历的节点是否在之前已遍历过，用哈希表存储所有已遍历节点的地址。具体逻辑如下： ​ 对链表进行遍历，在遍历时判断当前节点是否存在于哈希表中，若不存在则将该节点的地址存入哈希表，若存在则表明当前是第二次访问该节点，说明链表中存在环，返回TRUE。在遍历的过程中，若用于遍历的指针为NULL，则说明已到链表末尾，该链表无环，返回FALSE。 ​ 具体代码略。 时间复杂度：O(n)，n为链表的长度； 空间复杂度：O(n)，n为链表的长度，因为需要用到哈希表，哈希表中存储各个节点的地址。 也可以使用floyd判圈算法(龟兔赛跑法)。 ​ 我们可以让快指针和慢指针一开始都指向第一个节点。在循环中，慢指针每次移动一步，而快指针每次移动2步。 ​ 如果链表中无环，在出发后，快指针始终跑在慢指针的前面，直至快指针到点链表末尾，(NULL == pFast || NULL == pFast-&gt;next)判断条件成立，返回FALSE。 ​ 如果链表中有环，则快指针进入环后，会持续在环中兜圈，这样一来，快指针和慢指针必然会在某一次循环中相遇，判断到相遇后，我们就返回TRUE。 相遇情况举例： ​ 假设链表的长度为N，链表末尾节点接到了起始节点，形成一个环链表。在开始赛跑之前，快慢指针都指向起始节点，此时，快指针距离追上慢指针还差N步。每跑一轮，距离N = N-1，所以至多跑N轮后快慢指针再次相遇。 123456789101112131415161718192021222324// floyd判圈int HasCircle(Node *pHead)&#123; if(NULL == pHead || NULL == pHead-&gt;next) &#123; return FALSE; &#125; Node *pSlow = pHead, *pFast = pHead; do &#123; if(NULL == pFast || NULL == pFast-&gt;next) &#123; return FALSE; &#125; pSlow = pSlow-&gt;next; pFast = pFast-&gt;next-&gt;next; &#125;while(pSlow != pFast); return TRUE;&#125; 时间复杂度：O(n)，n为链表的长度； 空间复杂度：O(1) 相交链表 ​ 给定两个链表(非环链表)，找出并返回这两个链表相交的起始节点，如果两个链表不存在相交的节点，则返回NULL。 ​ 同样地，该题也可以用哈希表来记录已访问过的节点。先遍历第一个链表，将该链表的所有节点的地址存储到哈希表中。再遍历第一个链表，在遍历的同时判断当前遍历的节点是否已存在于哈希表中，若已存在则说明该节点在之前访问过，即这个节点是两个链表的相交节点。 ​ 具体代码略。 时间复杂度：O(m+n)，m和n为链表的长度； 空间复杂度：O(m)，m是第一个被遍历的链表长度。 ​ 双指针法： 我们可以观察相交链表，可以发现相交链表分为三个部分： A链表中不相交的部分，该部分的节点数设为a； B链表中不相交的部分，该部分的节点数设为b； A、B链表相交的部分，该部分的节点数设为c。 如此划分，则A链表的长度为：m = a + c，B链表的长度为：n = b + c。所以，当a = b时，m = n。 ​ 当c=0时，就是A、B两个链表不相交的情况。这里我们不能根据c = 0判断链表是否相交，因为如果根据这一条件判断的话，那岂不是又是之前使用哈希表的方法？之前我们使用哈希表完成判断链表是否相交的本质就是在找两个链表中是否存在同一个节点。我们需要知道同一个节点有多少个才能知道c的值是多少，想要A、B两个链表中完全相同的节点有多少个就又得去记录......所以不根据c = 0进行判断。 先考虑最容易想的情况，那就是a = b的情况： ​ 对于这种情况，我们会很直观的想到可以用两个指针pA和pB来同时遍历A、B两个链表。 ​ 若是相交链表，则pA和pB一定能同时到达第一个相交的节点。所以我们可以在每次移动pA和pB之前判断两个指针所指节点的地址是否相等，若相等则说明两个链表一定相交。 ​ 若不是相交链表，则pA和pB会同时到达A、B链表的尾节点(不相交也就是c=0，a=b，那么m=n嘛)。也就是说，在遍历的过程中，pA和pB会同时为NULL。所以，\"直到pA和pB同时为NULL也还没找到地址相同的节点\"可以作为链表不相交的条件。 再考虑一般情况，a != b(即m != n)： ​ 对于这种情况，按之前的方法显然是不能使pA和pB同时指向第一个相交节点的，所以不对之前的方法进行修改而直接使用是行不通的。既然我们是因为pA和pB不能同时到达第一个相交节点而无法判断链表是否相交，那么我们可以想想办法怎么让pA和pB可以同时到达第一个相交的节点。 所以我们需要再次对a != b的情况进行观察。 ​ 既然m = a + c, n = b + c，为了使pA和pB能够同时遍历到第一个相交的节点，应该寻找某个互补相等的条件。那么这样互补一下？m + b = n + a。根据这个公式，我们可以得出方案，pA和pB中的某个指针若到达了链表末尾，也就是说值为NULL了，那么我们就让它从另一个链表的头部重新进行遍历。这样一来，因为m + b = n + a，所以如果我们让pA和pB一直遍历下去的话，它们迟早会同时遍历到对方链表的末尾，若是相交链表，则是同时遍历到相交部分的末尾。对于相交链表，既然能够同时遍历到相交部分的末尾，那这不就说明了能够同时遍历到第一个相交的节点嘛！所以，问题就这样解决了。 12345678910111213141516171819202122232425262728293031323334Node *GetIntersectionNode(Node *list1, Node *list2)&#123; if(NULL == list1 || NULL == list2) &#123; return NULL; &#125; // 两个用于遍历的指针 Node *pList1 = list1, *pList2 = list2; // 进行遍历 while(pList1 != pList2) // pList1和pList2相等时退出遍历 &#123; if(NULL == pList1) // pList1 == NULL, pList2 != NULL &#123; pList1 = list2; // 移动到另一个链表的头部 pList2 = pList2-&gt;next; // pList2不为空, 继续往后遍历 &#125; else if(NULL == pList2) // pList1 != NULL, pLsit2 == NULL &#123; pList2 = list1; pList1 = pList1-&gt;next; &#125; else // pList1和pList2都不为空 &#123; pList1 = pList1-&gt;next; pList2 = pList2-&gt;next; &#125; &#125; // 若是相交链表, 此处返回的就是第一个相交节点的地址 // 若不是相交链表, 此处返回的是NULL(pList1和pList2同时遍历到对方链表的末尾) return pList1;&#125; 可以用三目运算符稍作改进： 1234567891011121314151617Node *GetIntersectionNode(Node *list1, Node *list2)&#123; if(NULL == list1 || NULL == list2) &#123; return NULL; &#125; Node *pList1 = list1, *pList2 = list2; while(pList1 != pList2) &#123; pList1 = NULL == pList1 ? list2 : pList1-&gt;next; pList2 = NULL == pList2 ? list1 : pList2-&gt;next; &#125; return pList1;&#125; 时间复杂度：O(m+n)，m和n是两个链表的长度； 空间复杂度：O(1)。 反转链表 ​ 在遍历链表时，将当前节点的指针域改为指向前一个节点。由于单链表的节点中没有指向前一个节点的指针域，所以需要事先存储该节点的前一个节点的地址。 ​ 在更改指针域之前还需要存储后一个节点的地址，以便在修改后将当前节点移动到下一个节点。 123456789101112void ReverseList(Node **ppHead)&#123; Node *p = NULL; while(NULL != *ppHead) &#123; Node *next = (*ppHead)-&gt;next; (*ppHead)-&gt;next = p; p = *ppHead; *ppHead = next; &#125; *ppHead = p;&#125; 时间复杂度：O(n)，n是链表的长度； 空间复杂度：O(1) 回文链表 ​ 由于单链表中的节点只有指向下一个节点的指针域，不能直接根据链表判断回文。 ​ 一种思路是先将链表中各个节点的值按顺序存储到数组中，然后利用双指针法对数组进行回文判断。 ​ 具体代码略。 时间复杂度：O(n)，n是链表的长度； 空间复杂度：O(n)，n是链表的长度，因为至少需要长度为n的数组来存储链表中各个节点的数据。 ​ 另一种思路是，先将链表的后半部分进行反转，这样就可以对链表使用双指针从两端向内依次判断了。在完成判断后再重新将后半部分的链表再次进行反转，将链表恢复回原先的链表。这个方法的缺点是在并发的情况下不安全。 ​ 对于反转链表可以使用与上一题同样的方法，由于我们需要反转的是链表的后半部分，所以需要先找到链表的中间节点。可以使用快慢指针来找中间节点，开始的时候快慢指针都指向首个节点，每次移动时，快指针移动两步，慢指针移动一步，当快指针移动到链表末尾时，慢指针就移动到链表的中间节点了。 时间复杂度：O(n)，n是链表的长度； 空间复杂度：O(1)。 123456789101112131415161718192021222324252627282930313233343536373839404142// 反转链表struct ListNode *ReverseList(Node *pHead)&#123; Node *p = NULL; while(NULL != pHead) &#123; Node *next = pHead-&gt;next; pHead-&gt;next = p; p = pHead; pHead = next; &#125; return p;&#125;// 判断回文链表bool IsPalindrome(Node* head)&#123; if(NULL == head) return true; // 使用快慢指针找到链表的中间节点 Node *pSlow = head, *pFast = head; while(NULL != pFast-&gt;next &amp;&amp; NULL != pFast-&gt;next-&gt;next) &#123; pSlow = pSlow-&gt;next; pFast = pFast-&gt;next-&gt;next; &#125; Node *pRear = ReverseList(pSlow-&gt;next); int result = 1; while(result &amp;&amp; NULL != pRear) &#123; if(head-&gt;val != pRear-&gt;val) &#123; result = 0; &#125; head = head-&gt;next; pRear = pRear-&gt;next; &#125; // 恢复后半部分的链表 pSlow-&gt;next = ReverseList(pRear); return result;&#125; ​ 最后还有一种递归的写法。 使用递归遍历链表如下： 12345678void TravelListInReverse(Node *pHead)&#123; if(NULL != pHead) &#123; TravelListInReverse(pHead-&gt;next); printf(&quot;%d &quot;, pHead-&gt;val); &#125;&#125; ​ 由于递归的特点，使得可以实现反向遍历链表，上面的函数，若链表为[1,3,5,7,9]那么最终输出的是9 7 5 3 1。 ​ 我们先用递归遍历到链表末尾，然后利用递归函数依次返回到上一级函数来实现从链表末尾往前与该节点对称的节点进行值的比较。 12345678910111213141516171819202122int Check(Node *pRear, Node **pFront)&#123; if(NULL != pRear) &#123; if(!Check(pRear-&gt;next, pFront)) &#123; return FALSE; &#125; if(pRear-&gt;val != (*pFront)-&gt;val) &#123; return FALSE; &#125; *pFront = (*pFront)-&gt;next; &#125; return TRUE;&#125;int IsPalindrome(Node* head)&#123; // pFront是用来从前往后遍历的指针 Node *pFront = head; return Check(head, &amp;pFront);&#125; 时间复杂度：O(n)，n是链表的长度； 空间复杂度：O(n)，n是链表的长度。 ​ 在一个函数中调用另一个函数时，计算机要进入被调函数之前跟踪它在当前函数中的位置，在栈中存放参数中的数据，存放后再进入被调函数。被调函数执行完毕后，栈顶元素(形参和其他局部变量)被弹出，以恢复在进行函数调用之前所在的函数。 ​ 所以在进行回文检查之前递归函数会在栈中创建n个栈帧，后面逐个弹出进行处理。 参看：234. 回文链表 - 力扣（Leetcode） 二进制链表转整数 可以使用按权值展开的方法来求二进制链表的十进制数。 不需要提前知道链表的长度，每次读取一个节点值时，可以把它视为二进制数的最低位，当读取下一个节点值时，再把已经读取到的结果乘以2，再将新读到的节点值作为当前二进制数的最低位。 12345678910int GetDecimalValue(Node* pHead)&#123; int res = 0; while(pHead != NULL) &#123; res = 2 * res + pHead-&gt;val; pHead = pHead-&gt;next; &#125; return res;&#125; 稍作改进： 12345678910111213int GetDecimalValue(Node* pHead)&#123; int res = 0; while(pHead != NULL) &#123; res &lt;&lt;= 1; // res *= 2; // 由于res左移2位,所以最低位必为0 // 因此可以直接使用或运算实现相加(因为无需进位) res |= pHead-&gt;val; pHead = pHead-&gt;next; &#125; return res;&#125; 链表中倒数第k个节点 ​ 使用快慢指针，先让快指针先走k步，然后快慢指针一起每次走1步，直到快指针为NULL。 1234567891011121314Node *GetKthFromEnd(Node* pHead, int k)&#123; Node *p = pHead; while(k--) &#123; p = p-&gt;next; &#125; while(p) &#123; pHead = pHead-&gt;next; p = p-&gt;next; &#125; return pHead;&#125; 时间复杂度：O(n)，n为链表长度； 空间复杂度：O(1)。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"链表之单链表基础(1)","slug":"链表之单链表基础-1","date":"2023-05-26T11:38:22.000Z","updated":"2023-05-27T08:56:12.598Z","comments":true,"path":"2023/05/26/链表之单链表基础-1/","link":"","permalink":"http://example.com/2023/05/26/%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80-1/","excerpt":"","text":"链表之单链表基础(1) ​ 链表和顺序表一样，是一种线性表。但是链表解决了顺序表需要预先设定表内存大小的问题，链表中的各个节点的内存都是按需分配的，这就使得链表非常灵活，需要存多少数据就创建多少个节点。另一方面，由于我们自己按需分配内存，所以导致链表在内存上不一定连续，具体分配到哪里的内存由操作系统决定。我们需要将这些分散的节点联系起来，这样我们才能方便地对它们进行遍历，而且，如果我们不把它们\"串\"起来，链表又怎么能是一种线性表呢？为了将各个节点\"串\"起来，我们为每个节点都增加一个区域——指针域，指针域存储下一个节点的地址，这样我们就能够通过前一个节点访问到下一个节点。这样的链表就是链表中最简单的单向链表。 单链表的结构 单链表的结构： 12345typedef struct Node&#123; int val; Node *next;&#125;Node; 在我们定义链表时，其实只需要定义一个指向首节点的指针，因为只要知道了链表中第一个节点的位置，后面所有的节点都可以通过各个节点的指针域来依次获取。 1Node *pHead = NULL; 由于C99之前没有bool数据类型，使用宏来定义布尔值： 12345#define OK 0;#define ERROR 1;#define TRUE 1;#define FALSE 0; 单链表的创建 对于创建，最常见的就是根据某数据的个数创建、根据某个数行创建和根据另一个链表进行创建。 先看看最简单的，根据某数据的个数进行创建。 由于创建链表的操作势必会修改指向首节点的指针本身，所以，我们要么把首节点的地址通过返回值返回并对指向首节点的指针进行赋值，要么通过二级指针来修改指向首节点的指针(如果使用的是C++，可以使用引用来修改指针本身，参数为Node *&amp;pHead)。 另外，每次新创建的新节点可以插入在链表的头部也可插入在链表的尾部。如果插入在头部，则最终的顺序和插入的顺序正好相反，例如建表时依次创建1,2,3,4,5，创建完成后，链表从前到后的元素依次为5,4,3,2,1。而尾插则最终链表节点的顺序与新建节点的顺序一致。 这里，我们通过函数参数来传递指向首节点的指针，在插入时使用头插法： 123456789101112131415161718192021void CreateListByVal(Node **ppHead, int val, int num)&#123; *ppHead = NULL; for(int i = 0; i &lt; num; ++i) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = NULL; // 头插 if(NULL == *ppHead) &#123; *ppHead = pNew; &#125; else &#123; pNew-&gt;next = *ppHead; *ppHead = pNew; &#125; &#125;&#125; 根据数组创建链表，使用尾插法： 由于每次需要插入到链表的尾部，需要知道尾部在哪，所以我们要定义一个尾指针，它始终指向末尾节点。 123456789101112131415161718192021222324// 根据数组[begin, end)范围的元素创建链表void CreateListByArr(Node **ppHead, int *begin, int *end)&#123; *ppHead = NULL; Node *pRear = NULL; // 尾指针 while(begin &lt; end) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = *begin; pNew-&gt;next = NULL; // 尾插 if(NULL == *ppHead) &#123; *ppHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; ++begin; &#125;&#125; 最后，根据另一个链表创建新的链表： 123456789101112131415161718192021222324void CreateListByList(Node **ppHead, const Node *pOther)&#123; *ppHead = NULL; Node *pRear = NULL; while(pOther != NULL) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = pOther-&gt;val; pNew-&gt;next = NULL; if(NULL == *ppHead) &#123; *ppHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; pOther = pOther-&gt;next; &#125;&#125; 单链表的插入 无论是插入还是删除，我们都需要先找到插入/删除位置的前一个节点位置。如果是直接找到要插入/删除的位置，而没有记录前一个位置，那么我们就无法把前一个位置的节点与后面的节点\"串\"起来，链表就断了。 另外，由于我们创建的链表是不带头节点的，在首个位置插入元素和在其它位置插入元素的逻辑不一样，导致我们需要对这些不同的情况分开判断。 (我们所有的例子，链表的索引都是从1开始的) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int InsertList(Node **ppHead, int val, int pos)&#123; if(pos &lt; 1) return ERROR; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = NULL; if(NULL == *ppHead) // 链表为空 &#123; *ppHead = pNew; return OK; &#125; else if(pos &lt; 2) // pos = 1, 新节点作为首节点 &#123; pNew-&gt;next = (*ppHead)-&gt;next; *ppHead = pNew; return OK; &#125; else &#123; // 找到插入位置的前一个位置pos-1 Node *p = *ppHead; // pos &lt;= 2 =&gt; pos == 2: 找到插入位置的前一个位置 // NULL == p-&gt;next: 遍历到链表尾节点时仍未找到要插入的前一个位置 while(pos &gt; 2 &amp;&amp; p != NULL) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1位置, 且pos-1位置的节点存在 if(p != NULL) &#123; pNew-&gt;next = p-&gt;next; p-&gt;next = pNew; return OK; &#125; else &#123; free(pNew); return ERROR; &#125; &#125;&#125; 单链表的删除 根据索引进行删除 根据索引pos进行删除：(索引pos从1开始)： 123456789101112131415161718192021222324252627282930313233343536int DelList(Node **ppHead, int pos)&#123; if(NULL == *ppHead || pos &lt; 1) return ERROR; if(1 == pos) // 删除链表首节点 &#123; Node *pTemp = *ppHead; *ppHead = pTemp-&gt;next; free(pTemp); return OK; &#125; else &#123; Node *p = *ppHead; // 查找pos-1位置的节点 while(pos &gt; 2 &amp;&amp; p-&gt;next != NULL) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1的位置且存在pos位置的节点 if(p-&gt;next != NULL) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); pTemp = NULL; return OK; &#125; else &#123; return ERROR; &#125; &#125;&#125; 根据数值进行删除 删除链表中所有值为val的节点： 需要注意删除首个节点和删除后续节点的操作不一样，需分别考虑。 123456789101112131415161718192021222324252627282930313233void DelListByVal(Node **ppHead, int val)&#123; if(NULL == *ppHead) return; // 删除值为val的首元素 while(*ppHead != NULL &amp;&amp; (*ppHead)-&gt;val == val) &#123; Node *pTemp = *ppHead; *ppHead = pTemp-&gt;next; free(pTemp); &#125; // 首元素存在且值不为val if(*ppHead == NULL) return; Node *p = *ppHead; while(p-&gt;next != NULL) &#123; if(p-&gt;next-&gt;val == val) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); // 删除了p后面的结点后, 不需要挪动p指针 // 因为被删除节点的后一个节点重新成为了p指向的下一个节点 // 继续判断即可 &#125; else &#123; p = p-&gt;next; &#125; &#125;&#125; 可以看到，由于删除第一个节点和删除后续节点的操作不一致，导致实现起来非常不方便，所以可以创建一个哑节点来统一操作： 123456789101112131415161718192021void DelListByVal(Node **ppHead, int val)&#123; Node dummyNode = &#123;-1, *ppHead&#125;; *ppHead = &amp;dummyNode; while((*ppHead)-&gt;next != NULL) &#123; if((*ppHead)-&gt;next-&gt;val == val) &#123; Node *pTemp = (*ppHead)-&gt;next; (*ppHead)-&gt;next = pTemp-&gt;next; free(pTemp); &#125; else &#123; (*ppHead) = (*ppHead)-&gt;next; &#125; &#125; *ppHead = dummyNode.next;&#125; 实际上，这种使用哑节点统一操作的方式比分别考虑不同情况的方式的效率高。既方便，效率又高，何乐而不为？ 单链表的清空 123456789void ClearList(Node **ppHead)&#123; while(*ppHead != NULL) &#123; Node *pTemp = (*ppHead)-&gt;next; free(*ppHead); *ppHead = pTemp; &#125;&#125; 单链表的遍历 123456789void PrintList(const Node *pHead)&#123; while(pHead != NULL) &#123; printf(&quot;%d &quot;, pHead-&gt;val); pHead = pHead-&gt;next; &#125; printf(&quot;\\n&quot;);&#125; 对单链表进行冒泡排序 ​ 冒泡排序每一趟冒泡都是从第一个元素开始的，而不带哑节点的单链表中起始两个节点的交换操作和其他位置相邻两个节点的交换操作的逻辑不一样(起始两个节点在交换时，这两个节点前面没有任何节点，要将头指针重新指向交换操作后的第一个节点) ​ 为了使得交换起始两个节点与交换后续相邻节点的操作保持一致(保持一致后，便于编写循环)，需要创建一个临时的哑节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void SortList(Node **ppHead)&#123; int nodeNum = 0; Node *p = *ppHead; while(p != NULL) &#123; p = p-&gt;next; ++nodeNum; &#125; // 将一个哑节点作为链表的第一个节点, 便于操作 Node dummyNode; dummyNode.next = *ppHead; *ppHead = p = &amp;dummyNode; // printf(&quot;begin sort:\\n&quot;); for(int i = 0; i &lt; nodeNum; ++i) &#123; for(int j = 0; j &lt; nodeNum - i - 1; ++j) &#123; // printf(&quot;(%d and %d)\\n&quot;, p-&gt;next-&gt;val, p-&gt;next-&gt;next-&gt;val); // PrintList((*ppHead)-&gt;next); // 判断p2后的两个节点是否需要交换 if(p-&gt;next-&gt;val &gt; p-&gt;next-&gt;next-&gt;val) &#123; // a, b, c, d // a: p的位置 // b: pTemp1的位置 // d: pTemp3的位置 Node *pTemp1 = p-&gt;next; Node *pTemp3 = p-&gt;next-&gt;next-&gt;next; p-&gt;next = p-&gt;next-&gt;next; p-&gt;next-&gt;next = pTemp1; p-&gt;next-&gt;next-&gt;next = pTemp3; &#125; p = p-&gt;next; &#125; // printf(&quot;\\n&quot;); p = &amp;dummyNode; &#125; // 将头指针重新指向存储实际数据的第一个节点 *ppHead = dummyNode.next;&#125; 删除已序单链表中值重复的节点 ​ 由于是已序的单链表，所以可以一次遍历就能完成去重。 ​ 使用两个指针，一个快指针，一个慢指针，指向链表中的相邻两个节点，判断数据是否重复，若重复则删除快指针指向的节点，慢指针无需移动，只需将快指针移动到被删除节点的下一个节点，继续判断。若不重复则使快指针和慢指针同时往后挪一位。 123456789101112131415161718192021222324void DelSortedListDuplicate(Node **ppHead)&#123; Node *pSlow = *ppHead; Node *pPrev = pSlow-&gt;next; // printf(&quot;begin del dup\\n&quot;); while(pPrev != NULL) &#123; if(pSlow-&gt;val == pPrev-&gt;val) &#123; Node *pTemp = pPrev; pSlow-&gt;next = pPrev-&gt;next; free(pTemp); pPrev = pSlow-&gt;next; // 删除后, pSlow不动, pPrev移动到被删除节点的下一个节点 &#125; else &#123; pSlow = pSlow-&gt;next; pPrev = pPrev-&gt;next; &#125; // PrintList(*ppHead); &#125;&#125; 将之前写的所有操作在C++中用类进行封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367#include &lt;iostream&gt;template&lt;typename T&gt;class LinkedList&#123;private: struct Node &#123; T val; Node *next; &#125;; Node *pHead;public: LinkedList(); LinkedList(T val, int num); LinkedList(T *begin, T *end); LinkedList(const LinkedList &amp;list); bool Insert(T val, int pos); bool DeleteByPos(int pos); void DeleteByVal(T val); void Sort(); void DelSortedDuplicate(); void Print(); int Length(); void Clean();&#125;;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList()&#123; pHead = nullptr;&#125;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList(T val, int num): pHead(nullptr)&#123; for(int i = 0; i &lt; num; ++i) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = nullptr; // 头插 if(nullptr == pHead) &#123; pHead = pNew; &#125; else &#123; pNew-&gt;next = pHead; pHead = pNew; &#125; &#125;&#125;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList(T *begin, T *end): pHead(nullptr)&#123; Node *pRear = nullptr; // 尾指针 while(begin &lt; end) &#123; // std::cout &lt;&lt; &quot;create: &quot; &lt;&lt; *begin &lt;&lt; std::endl; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = *begin; pNew-&gt;next = nullptr; // 尾插 if(nullptr == pHead) &#123; pHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; ++begin; &#125;&#125;template&lt;typename T&gt;LinkedList&lt;T&gt;::LinkedList(const LinkedList &amp;list): pHead(nullptr)&#123; Node *pRear = nullptr; while(list.pHead != nullptr) &#123; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = list.pHead-&gt;val; pNew-&gt;next = nullptr; if(nullptr == *pHead) &#123; *pHead = pRear = pNew; &#125; else &#123; pRear-&gt;next = pNew; pRear = pNew; &#125; list.pHead = list.pHead-&gt;next; &#125;&#125;template&lt;typename T&gt;int LinkedList&lt;T&gt;::Length()&#123; int len = 0; Node *p = pHead; while(p != nullptr) &#123; ++len; p = p-&gt;next; &#125; return len;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::Print()&#123; Node *p = pHead; while(p != nullptr) &#123; printf(&quot;%d &quot;, p-&gt;val); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;template&lt;typename T&gt;bool LinkedList&lt;T&gt;::Insert(T val, int pos)&#123; if(pos &lt; 1) return false; Node *pNew = (Node*)malloc(sizeof(Node)); pNew-&gt;val = val; pNew-&gt;next = nullptr; if(nullptr == pHead) // 链表为空 &#123; pHead = pNew; return true; &#125; else if(pos &lt; 2) // pos = 1, 新节点作为首节点 &#123; pNew-&gt;next = pHead-&gt;next; pHead = pNew; return true; &#125; else &#123; // 找到插入位置的前一个位置pos-1 Node *p = pHead; // pos &lt;= 2 =&gt; pos == 2: 找到插入位置的前一个位置 // NULL == p-&gt;next: 遍历到链表尾节点时仍未找到要插入的前一个位置 while(pos &gt; 2 &amp;&amp; p != nullptr) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1位置, 且pos-1位置的节点存在 if(p != nullptr) &#123; pNew-&gt;next = p-&gt;next; p-&gt;next = pNew; return true; &#125; else &#123; free(pNew); return false; &#125; &#125;&#125;template&lt;typename T&gt;bool LinkedList&lt;T&gt;::DeleteByPos(int pos)&#123; if(nullptr == pHead || pos &lt; 1) return false; if(1 == pos) // 删除链表首节点 &#123; Node *pTemp = pHead; pHead = pTemp-&gt;next; free(pTemp); return true; &#125; else &#123; Node *p = pHead; // 查找pos-1位置的节点 while(pos &gt; 2 &amp;&amp; p-&gt;next != nullptr) &#123; p = p-&gt;next; --pos; &#125; // 找到pos-1的位置且存在pos位置的节点 if(p-&gt;next != nullptr) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); pTemp = NULL; return true; &#125; else &#123; return false; &#125; &#125;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::DeleteByVal(T val)&#123; if(nullptr == pHead) return; // 删除值为val的首元素 while(pHead != nullptr &amp;&amp; pHead-&gt;val == val) &#123; Node *pTemp = pHead; pHead = pTemp-&gt;next; free(pTemp); &#125; // 首元素存在且值不为val if(nullptr == pHead) return; Node *p = pHead; while(p-&gt;next != nullptr) &#123; if(p-&gt;next-&gt;val == val) &#123; Node *pTemp = p-&gt;next; p-&gt;next = pTemp-&gt;next; free(pTemp); // 删除了p后面的结点后, 不需要挪动p指针 // 因为被删除节点的后一个节点重新成为了p指向的下一个节点 // 继续判断即可 &#125; else &#123; p = p-&gt;next; &#125; &#125;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::Sort()&#123; int nodeNum = 0; Node *p = pHead; while(p != NULL) &#123; p = p-&gt;next; ++nodeNum; &#125; // 将一个哑节点作为链表的第一个节点, 便于操作 Node dummyNode; dummyNode.next = pHead; pHead = p = &amp;dummyNode; // printf(&quot;begin sort:\\n&quot;); for(int i = 0; i &lt; nodeNum; ++i) &#123; for(int j = 0; j &lt; nodeNum - i - 1; ++j) &#123; // printf(&quot;(%d and %d)\\n&quot;, p-&gt;next-&gt;val, p-&gt;next-&gt;next-&gt;val); // PrintList((*ppHead)-&gt;next); // 判断p后的两个节点是否需要交换 if(p-&gt;next-&gt;val &gt; p-&gt;next-&gt;next-&gt;val) &#123; // a, b, c, d // a: p2的位置 // b: pTemp1的位置 // c: pTemp2的位置 Node *pTemp1 = p-&gt;next; Node *pTemp3 = p-&gt;next-&gt;next-&gt;next; p-&gt;next = p-&gt;next-&gt;next; p-&gt;next-&gt;next = pTemp1; p-&gt;next-&gt;next-&gt;next = pTemp3; &#125; p = p-&gt;next; &#125; // printf(&quot;\\n&quot;); p = &amp;dummyNode; &#125; pHead = dummyNode.next;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::DelSortedDuplicate()&#123; Node *pSlow = pHead; Node *pPrev = pSlow-&gt;next; // printf(&quot;begin del dup\\n&quot;); while(pPrev != nullptr) &#123; if(pSlow-&gt;val == pPrev-&gt;val) &#123; Node *pTemp = pPrev; pSlow-&gt;next = pPrev-&gt;next; free(pTemp); pPrev = pSlow-&gt;next; // 删除后, pSlow不动, pPrev移动到被删除节点的下一个节点 &#125; else &#123; pSlow = pSlow-&gt;next; pPrev = pPrev-&gt;next; &#125; // Print(); &#125;&#125;template&lt;typename T&gt;void LinkedList&lt;T&gt;::Clean()&#123; while(pHead != nullptr) &#123; Node *pTemp = pHead-&gt;next; free(pHead); pHead = pTemp; &#125;&#125;int main()&#123; int arr[10] = &#123;1, 8, 4, 4, 5, 5, 7, 8, 5, 10&#125;; LinkedList&lt;int&gt; list(&amp;arr[0], &amp;arr[10]); list.Print(); std::cout &lt;&lt; &quot;length of list: &quot; &lt;&lt; list.Length() &lt;&lt; std::endl; list.Insert(100, 5); list.Print(); list.DeleteByPos(1); list.Print(); list.DeleteByVal(8); list.Print(); list.Sort(); list.Print(); list.DelSortedDuplicate(); list.Print(); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[],"tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}